#!/usr/bin/env python

"""
pytopo: show topographic maps using data files from Topo! CD
to generate a map at the specified coordinates.
Home page and more documentation: http://shallowsky.com/software/topo/

Copyright 2005 - 2015 by Akkana Peck, akkana@shallowsky.com
Please feel free to use, distribute or modify this program
under the terms of the GPL v2 or, at your option, a later GPL version.
I'd appreciate hearing about it if you make any changes.

Finding zero-length files:
 find Maps/opencyclemap/13 -size 0
 cd Maps/opencyclemap/13/1429
 #wget http://a.andy.sandbox.cloudmade.com/tiles/cycle/13/1429/3230.png
 wget http://b.tile.opencyclemap.org/cycle/13/1473/3236.png

Downloading your own file collection (faster than doing it interactively):
cd Maps/opencyclemap
  foreach level (*)
    cd Maps/opencyclemap/$level
    foreach dir (*)
      cd Maps/opencyclemap/$level/$dir
        foreach fil (`find . -size 0`)
          echo $dir/$fil
          rm $fil
          #wget http://a.andy.sandbox.cloudmade.com/tiles/cycle/$level/$dir/$fil
          wget http://b.tile.opencyclemap.org/cycle/$level/$dir/$fil
        end
    end
  end
end

TODO: allow configuration of colors, line thickness etc.
"""

# We will do all calculations in decimal degrees,
# but take inputs in deg.decimal_minutes.

VersionString = "PyTopo Version 1.2 by Akkana Peck"

import sys, os, glob, math
import gtk, gobject, glib
import gc
import pango
settings = gtk.settings_get_default()
settings.set_property("gtk-touchscreen-mode", True)

import xml.dom.minidom
import zipfile

import types, urllib, re
import collections

# If we download files, we'll try to use the magic library to make
# sure we got the right file type. But no need to import it
# if we're not downloading anything.
magic_parser = None

#import pdb

#import traceback
#import cProfile

#########################################################
#
# Global Variables that you can override in your .pytopo
# (which may live in $HOME or in $home/.config/pytopo):
#

# Map collections you have, with format information.
# You must define at least one collection in .pytopo.
# It should be a list of instances of MapCollection subtypes.
# Example:
#Collections = [
#    Topo1MapCollection( "mojave", "/home/name/Maps/emj_data", 7.5, 269, 328 ),
#    GenericMapCollection( "pa-geo", "/home/name/Maps/pa-geo-300",
#                          "pa-geo-300-", ".jpg",
#                          -122.497, 37.498, 300, 400, 10746, 13124,
#                          2, True, False )
#]
# The currently supported types are:
#
# Topo1MapCollection: data from local-area Topo! packages,
#   the kind that have 7.5 minute and 15 minute varieties included.
#    (self, _name, _location, _series, tile_w, tile_h):
#
# Topo2MapCollection: data from local-area Topo! packages that
#   have only the 7.5-minute series and use jpg instead of gif.
#    (collection_name, directory_path, file_prefix, tile_w, tile_h):
#
# GenericMapCollection: a more general reader, for maps you split up
#   yourself or the Topo! national park maps.
#   ( collection_name, directory_path, filename_prefix, filename_suffix,
#     left_longitude, top_latitude, x_scale, y_scale,
#     num_digits, use_dash, latitude_first )
#    Filenames might look like: pa-map-03-17.png
#    where prefix and suffix are pa-map- and .png,
#    left_longitude and top_latitude specify the top left corner of
#    the (0, 0) image in degrees.decimal_minutes,
#    x_scale and y_scale are in pixels per degree,
#    num_digits is the number of digits used to specify grid points,
#    usedash specifies whether to put a dash between grid numbers,
#    and latitude_first indicates that latitude changes more rapidly
#    than longitude (i.e. in pa-map-03-17.png, it's the third map over
#    and the 17th map down).
# GenericMapCollection is subject to change (to add new parameters) as
# different types of map are added and the rules need to be generalized.
#Collections = []

# Named sites you might want to use as starting points.
# Format: [ sitename, longitude, latitude, collection_name ]
# Coordinates are in degrees.decimal_minutes.
# Example:
# KnownSites = [
#     # San Francisco Bay Area
#     [ "saratogagap", 122.0725, 37.155, "sfr" ],
#     [ "lexington", 121.594, 37.12, "sfr" ],
#     # Death Valley
#     [ "zabriskie", 116.475, 36.245, "deathvalley" ],
#     # From the Big Sur map:
#     [ "pinnacles", 121.0865, 36.3247, "bigsur" ],
#     ]
#KnownSites = []

#
# End of variables likely to need customization.
#
#########################################################

#########################################################
#
# Types of map collections we understand.
# If you split your own map into maplets, you may
# want to define your own subclass to handle it:
# see GenericMapCollection for an example.
#
# You can put your own subclasses in ~/.pytopo,
# but please consider contributing them so I can
# integrate them into future PyTopo releases!
#

Debug = False

class MapCollection:

    """A MapCollection is a set of maplet tiles on disk,
combined with knowledge about the geographic coordinates
and scale of those tiles so they can be drawn in a map window.

Child classes implementing MapCollection must define functions
__init__, get_maplet, draw_map, and get_top_left.
Get_top_left() is only for debugging, when you're trying to figure out
map coordinates and need a starting place. Should probably remove it.
"""

    def __init__(self, _name, _location):
        self.name = _name
        self.location = _location

        # Set some defaults so that we can test pytopo with a null collection:
        self.img_width = 100
        self.img_height = 100
        self.xscale = 100.
        self.yscale = 100.

    def get_maplet(self, longitude, latitude):
        """Returns pixbuf, x_offset, y_offset:
         - the pixbuf for the maplet image (or null)
         - the offset in pixels into the image for the given coordinates,
           from top left.
        """
        return None, 0, 0

    def draw_map(self, center_lon, center_lat, drawwin):
        """Draw a map in a window, centered around the specified coordinates.
        drawwin is a DrawWin object."""
        return

    def get_top_left(self):
        """A way to display some part of a map collection even if we're fuzzy
        on the coordinates -- get the coordinate of the first maplet
        and return as longitude, latitude."""
        return 0, 0

    def zoom(self, amount, latitude=45):
        """Zoom by the given number of steps (positive to zoom in,
        negative to zoom out). Pass amount=0 to recalculate/redraw.
        Some map collections need to know latitude to determine scale.
        """
        return

    def zoom_to(self, newzoom, latitude=45):
        """Zoom to a specific zoom level and recalculate scales.
        Some map collections need to know latitude to determine scale.
        """
        return

    def exists(self):
        """Does the collection have its map files in place?"""
        self.location = os.path.expanduser(self.location)
        return os.access(self.location, os.X_OK)

    # Spherical Mercator code,
    # from http://wiki.openstreetmap.org/wiki/Mercator#Python
    def y2lat(self, a):
        return 180.0/math.pi*(2.0*math.atan(math.exp(a*math.pi/180.0))
                              -math.pi/2.0)
    def lat2y(self, a):
        return 180.0/math.pi*math.log(math.tan(math.pi/4.0
                                               +a*(math.pi/180.0)/2.0))

    def zoom_to_bounds(self, minlon, minlat, maxlon, maxlat):
        # http://gis.stackexchange.com/questions/19632/how-to-calculate-the-optimal-zoom-level-to-display-two-or-more-points-on-a-map
        # Find spherical Mercator distances:
        xdist = maxlon - minlon
        ydist = self.lat2y(maxlat) - self.lat2y(minlat)
        # The equator is about 40m meters long projected and tiles are
        # 256 pixels wide, so the pixel length of that map at a given
        # zoom level is about 256 * distance/40000000 * 2^zoom.
        # But it needs another factor of 100000, determined empirically.
        mult = 256. * 100000. / 40000000.
        z = 0

        # Handle the case of a single point
        if xdist == 0 or ydist == 0:
            print "Single point! Zooming to maxzoom", self.maxzoom
            self.zoom_to(self.maxzoom)
            return

        while z <= self.maxzoom:
            powz = pow(2, z)
            w = xdist * mult * powz
            h = ydist * mult * powz
            # print z, ": Size", w, "x", h
            if w > 800 or h > 600:
                self.zoom_to(z-1)
                return
            z += 1
        print "Eek, couldn't fit bounding box"
        self.zoom_to(12)

class TiledMapCollection(MapCollection):

    """Code common to map collections that have raster tiles of a fixed size.
TiledMapCollection classes must implement
  (pixbuf, x_off, y_off, pathname) = get_maplet(curlon, curlat)
  (pixbuf, newpath) = get_next_maplet(oldpath, dX, dY)
"""

    def __init__(self, _name, _location, _tile_w, _tile_h):
        MapCollection.__init__(self, _name, _location)
        self.img_width = _tile_w
        self.img_height = _tile_h

        # For collections that support downloading new tiles,
        # keep a list of tiles that still need downloading:
        self.download_tiles = DownloadTileQueue()
        self.download_func = None
        self.download_failures = 0

    def draw_map(self, center_lon, center_lat, mapwin):
        """Draw maplets at the specified coordinates, to fill the mapwin."""

        # Get the current window size:
        win_width, win_height = mapwin.get_size()
        if (Debug):
            print "Window is", win_width, "x", win_height

        # Now that we have a latitude, call zoom so we can finally
        # set the x and y scales accurately.
        self.zoom(0, center_lat)

        # Find the coordinate boundaries for the set of maps to draw.
        # This may (indeed, usually will) include maps partly off the screen,
        # so the coordinates will span a greater area than the visible window.
        if (Debug):
            print "Calculating boundaries: min =", \
                   MapUtils.DecDegToDegMinStr(center_lon), \
                   center_lon, "+/-", win_width, \
                   "/", self.xscale, "/ 2"
        min_lon = center_lon - win_width / self.xscale / 2
        max_lon = center_lon + win_width / self.xscale / 2
        min_lat = center_lat - win_height / self.yscale / 2
        max_lat = center_lat + win_height / self.yscale / 2

        if (Debug):
            print "Map from", min_lon, MapUtils.DecDegToDegMinStr(min_lon), \
                   MapUtils.DecDegToDegMinStr(min_lat), \
                   "to", MapUtils.DecDegToDegMinStr(max_lon), \
                   MapUtils.DecDegToDegMinStr(max_lat)

        # Start from the upper left: min_lon, max_lat

        #pdb.set_trace()
        curlat = max_lat
        cur_y = 0
        y_maplet_name = None
        initial_x_off = None
        while cur_y < win_height:
            curlon = min_lon
            cur_x = 0
            x_maplet_name = None
            while cur_x < win_width:

                # Reset the expected image size:
                w = self.img_width
                h = self.img_height

                # Is it the first maplet in this row?
                if x_maplet_name == None:

                    # Is it the first maplet in the map --
                    # usually the one in the upper left corner?
                    # Then we need to specify coordinates.
                    if y_maplet_name == None:
                        pixbuf, x_off, y_off, x_maplet_name = \
                            self.get_maplet(curlon, curlat)

                        # Save the x offset: we'll need it for the
                        # beginning of each subsequent row.
                        initial_x_off = x_off

                    # Not upper left corner --
                    # must be the beginning of a new row.
                    # Get the maplet below the beginning of the last row.
                    else:
                        pixbuf, x_maplet_name = \
                            self.get_next_maplet(y_maplet_name, 0, 1)
                        x_off = initial_x_off
                        y_off = 0

                    # Either way, whether or not we got a pixbuf,
                    # if we're at the beginning of a row, save the
                    # beginning-of-row maplet name and the offset:
                    if cur_x == 0:
                        y_maplet_name = x_maplet_name

                # Continuing an existing row.
                # Get the maplet to the right of the last one.
                else:
                    pixbuf, x_maplet_name = self.get_next_maplet(x_maplet_name,
                                                                 1, 0)
                    x_off = 0

                if Debug:
                    print "    ", x_maplet_name

                x = cur_x
                y = cur_y

                # If the pixbuf wasn't available, the collection may return
                # a URL to be downloaded. Check for that:
                if type(pixbuf) == types.TupleType:
                    # XXX Make sure it's not not already queued for download:
                    self.download_tiles.push(pixbuf[0], pixbuf[1],
                                             x, y, x_off, y_off,
                                             mapwin)
                    pixbuf = None

                w, h = self.draw_one_tile(pixbuf, mapwin, x, y, x_off, y_off)
                # You may ask, why not just do this subtraction before
                # draw_pixbuf so we don't have to subtract w and h twice?
                # Alas, we may not have the real w and h until we've done
                # pixbuf.get_width(), so we'd be subtracting the wrong thing.
                # XXX Not really true any more, since we're assuming fixed
                # XXX tile size. Revisit this!
                cur_x += w
                curlon += float(w) / self.xscale

            if (Debug):
                print " "
                print "New row: adding y =", h,
                print "Subtracting lat", float(h) / self.yscale

            cur_y += h
            curlat -= float(h) / self.yscale
            #curlat -= float(self.img_height) / self.yscale

        # Free all pixbuf data. Just letting pixbuf go out of scope
        # isn't enough; it's necessary to force garbage collection
        # otherwise Python will let the process grow until it
        # fills all of memory.
        # http://www.daa.com.au/pipermail/pygtk/2003-December/006499.html
        # (At this indentation level, we free after drawing the whole map.)
        gc.collect()

        # If we queued any downloads, schedule a function to take care of that:
        if len(self.download_tiles) > 0 and self.download_func == None:
            gobject.timeout_add(300, self.download_more)

    def get_next_maplet_name(self, fullpathname, dX, dY):
        """Starting from a maplet name, get the one a set distance away."""
        return

    def get_next_maplet(self, fullpathname, dX, dY):
        """Given a maplet's pathname, get the next or previous one.
        May not work for jumps more than 1 in any direction.
        Returns pixbuf, newpath (either may be None).
        """
        return

    def draw_one_tile(self, pixbuf, mapwin, x, y, x_off, y_off):
        """Draw a single tile, perhaps after downloading it."""
        if pixbuf != None:
            w = pixbuf.get_width() - x_off
            h = pixbuf.get_height() - y_off
            if (Debug):
                print "img size:", pixbuf.get_width(), \
                      pixbuf.get_height()

            # If the image won't completely fill the grid space,
            # fill the whole rectangle first with black.
            # Note: this may not guard against images with
            # transparent areas. Don't do that.
            if (pixbuf.get_width() < self.img_width or
                pixbuf.get_height() < self.img_height):
                mapwin.set_bg_color()
                mapwin.draw_rectangle(1, x, y,
                                      self.img_width, self.img_height)
                if (Debug):
                    print "Filling in background:", x, y,
                    print self.img_width, self.img_height

            # if (Debug):
            #     print "Drawing maplet for",
            #     print MapUtils.DecDegToDegMinStr(curlon),
            #     print MapUtils.DecDegToDegMinStr(curlat),
            #     print "at", x, y, "offset", x_off, y_off,
            #     print "size", w, h

            mapwin.draw_pixbuf(pixbuf, x_off, y_off, x, y, w, h)

            # Make sure the pixbuf goes out of scope properly:
            pixbuf = 0
        else:
            # if (Debug):
            #     print "No maplet for", curlon, curlat,
            #     print "at", x, y, "offset", x_off, y_off
            mapwin.set_bg_color()
            w = self.img_width - x_off
            h = self.img_height - y_off
            mapwin.draw_rectangle(1, x, y, w, h)

        # Useful when testing:
        if (Debug):
            mapwin.set_color(mapwin.grid_color)
            mapwin.draw_rectangle(0, x, y, w, h)
            mapwin.draw_line(x, y, x+w, y+h)
            mapwin.set_bg_color()
        return w, h

    def download_finished(self, path):
        """Callback when a tile finishes downloading.
           The path argument is either the local file path just downloaded,
           or an exception, e.g. IOError.
        """

        # If we got too many failures -- usually IOError,
        # perhaps we're offline -- path will be None here.
        # In that case, just give up on downloading.
        if path == None:
            self.download_failures += 1
            if self.download_failures > 10:
                print "\nDownload failed; giving up"
                self.download_func = None
                # Clear self.download_tiles, so that if the net returns
                # we'll start on new stuff, not old stuff.
                # Not clear if this is the right thing to do or not.
                self.download_tiles = DownloadTileQueue()
                self.download_failures = 0
                return

        # Otherwise, we got a path for a successful tile download.
        # Reset the failure counter:
        #self.download_failures += 1

        # Draw it on the map:
        url, path, x, y, x_off, y_off, mapwin = self.download_tiles.pop()
        try:
            pixbuf = gtk.gdk.pixbuf_new_from_file(path)
            self.draw_one_tile(pixbuf, mapwin, x, y, x_off, y_off)
        except glib.GError, e:
            print "Couldn't draw tile:", e,
            if not Debug:
                print "... deleting"
            else:
                print ""
            print ""
            if os.path.exists(path) and not Debug:
                os.unlink(path)
            self.download_failures += 1
            # Usually this means OSM gave us a text file containing
            # a string like "Tile Not Available"
        except Exception, e:
            print "Error drawing tile:", e
            self.download_failures += 1

        # Redraw any trackpoints, since they might have been overwritten:
        mapwin.draw_trackpoints()

        # It's okay to start a new download now:
        self.download_func = None

        # Anything more to download?
        if len(self.download_tiles) > 0:
            self.download_more()

    def download_more(self):
        """Idle/timeout proc to download any pending tiles.
           Should always return False so it won't get rescheduled.
           Eventually this should download in a separate thread.
        """

        # If we already have a download going, don't start another one
        # (eventually we'll want to run several in parallel).
        if self.download_func != None:
            if Debug:
                print "There's already a download going; not downloading more"
            return False

        # If there are no more tiles to download, we're done:
        if len(self.download_tiles) == 0:
            self.download_func = None
            return False

        url, path, x, y, x_off, y_off, mapwin = self.download_tiles.peek()
        # Don't actually pop() it until it has downloaded.
        #urllib.urlretrieve(url, path)
        self.download_func = start_job(download_job(url, path,
                                                    self.download_finished))
        if Debug:
            print "Started download %s to %s" % (url, path)

        return False

class OSMMapCollection(TiledMapCollection):

    """
    A collection of tiles downloaded from the OpenStreetMap project
    or one of its renderers, using the OSM naming scheme.
    See also http://tfischernet.wordpress.com/2009/05/04/drawing-gps-traces-on-map-tiles-from-openstreetmap/
    """

    def __init__(self, _name, _location, _ext,
                 _img_width, _img_height, _init_zoom,
                 _download_url=None, maxzoom=19):
        """arguments:
        name         -- user-visible name of the collection
        location     -- directory on disk where the maps reside
        ext          -- filename extension including the dot, e.g. .jpg
        img_width    -- width of each maplet
        img_height   -- height of each maplet
        init_zoom    -- default initial zoom level
        download_url -- try to download missing maplets from here
        """
        TiledMapCollection.__init__(self, _name, _location,
                                    _img_width, _img_height)
        self.ext = _ext
        self.img_width = _img_width
        self.img_height = _img_height
        self.zoomlevel = _init_zoom
        self.powzoom = 2.0 ** self.zoomlevel   # to avoid re-re-calculating
        self.download_url = _download_url
        self.maxzoom = maxzoom

        self.location = os.path.expanduser(self.location)

        # Handle ~ format for location

        # If we're download-capable, we'd better have a directory
        # to download to, so make it if it's not there already:
        if self.download_url and not os.access(self.location, os.W_OK):
            # XXX wrap in a try, show user-visible error dialog!
            os.makedirs(self.location)

        # Call zoom so we set all scales appropriately:
        self.zoom(0)

    # Utilities for mapping tiles to/from degrees.
    # From http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames
    def deg2num(self, lat_deg, lon_deg, zoom=None):
        """Map coordinates to tile numbers and offsets"""
        if zoom:
            powzoom = 2.0 ** zoom
        else:
            powzoom = self.powzoom
        lat_rad = math.radians(lat_deg)
        xtilef = (lon_deg + 180.0) / 360.0 * powzoom
        ytilef = ((1.0 - math.log(math.tan(lat_rad) +
                                  (1 / math.cos(lat_rad))) / math.pi)
                  / 2.0 * powzoom)
        xtile = int(xtilef)
        ytile = int(ytilef)

        tilesize = 256
        x_off = int((xtilef - xtile) * tilesize)
        y_off = int((ytilef - ytile) * tilesize)

        return(xtile, ytile, x_off, y_off)

    def num2deg(self, xtile, ytile):
        """Map file numbers to coordinates"""
        lon_deg = xtile / self.powzoom * 360.0 - 180.0
        lat_rad = math.atan(math.sinh(math.pi * (1 - 2 * ytile / self.powzoom)))
        lat_deg = math.degrees(lat_rad)
        return(lat_deg, lon_deg)

    def zoom_to(self, newzoom, latitude=45):
        """Zoom to a specific zoom level, updating scales accordingly.
        Pass latitude for map collections (e.g. OSM) that cover
        large areas so scale will tend to vary with latitude.
        """

        if self.zoomlevel != newzoom:
            if newzoom > self.maxzoom:
                print "Can't zoom past level", self.maxzoom, "in", \
                    self.name, "map collections"
                return
            self.zoomlevel = newzoom
            self.powzoom = 2.0 ** self.zoomlevel

        # Get scale, in pixels / degree.
        # (2 ** zoomlevel) tiles covers the whole world.
        self.xscale = self.powzoom * 180./256.

        # But because of the Mercator projection,
        # yscale has to be adjusted for latitude.
        (xtile, ytile, x_off, y_off) = self.deg2num(latitude, 180)
        (lat1, lon1) = self.num2deg(xtile, ytile)
        (lat2, lon2) = self.num2deg(xtile+1, ytile-1)
        self.xscale = 256. / (lon2 - lon1)
        self.yscale = 256. / (lat2 - lat1)
        if Debug:
            print "Zoom to %d: Calculated scales: %f, %f" \
                % (self.zoomlevel, self.xscale, self.yscale)
        return

    def zoom(self, amount, latitude=45):
        """Zoom in or out by the specified amount,
        updating the scales appropriately.
        Call zoom(0) to update x/y scales without changing zoom level.
        Pass latitude for map collections (e.g. OSM) that cover
        large areas so scale will tend to vary with latitude.
        """
        self.zoom_to(self.zoomlevel + amount, latitude)

    def get_maplet(self, longitude, latitude):
        """Fetch or queue download for the maplet containing the
        specified coordinates.
        Input coordinates are in decimal degrees.
        Returns pixbuf, x_offset, y_offset, filename
        where offsets are pixels from top left of the specified coords
        and pixbuf or (less often) filename may be None.
        """

        (xtile, ytile, x_off, y_off) = self.deg2num(latitude, longitude)

        filename = os.path.join(self.location, str(self.zoomlevel),
                                str(xtile), str(ytile)) + self.ext
        pixbuf = self.fetch_or_download_maplet(filename)
        return pixbuf, x_off, y_off, filename

    # maplet size is 256. Files per dir:
    # at zoomlevel 12, 28
    # at zoomlevel 13, 53
    # at zoomlevel 14, 107
    def get_next_maplet_name(self, fullpathname, dX, dY):
        """Starting from a maplet name, get the one a set distance away."""
        fulldir, filename = os.path.split(fullpathname)
        ystr, ext = os.path.splitext(filename)
        zoomdir, xstr = os.path.split(fulldir)
        xstr = str(int(xstr) + dX)
        ystr = str(int(ystr) + dY)

        return os.path.join(zoomdir, xstr, ystr + ext)

    def get_next_maplet(self, fullpathname, dX, dY):
        """Given a maplet's pathname, get the next or previous one.
        May not work for jumps more than 1 in any direction.
        Returns pixbuf, newpath (either may be None).
        """
        newpath = self.get_next_maplet_name(fullpathname, dX, dY)
        if newpath == None:
            return None, newpath

        pixbuf = self.fetch_or_download_maplet(newpath)
        return pixbuf, newpath

    def url_from_path(self, path, zoomlevel=None):
        """URL we need to get the given tile file"""
        if not zoomlevel:
            zoomlevel = self.zoomlevel
        xdir, basename = os.path.split(path)
        xdir = os.path.basename(xdir)
        return self.download_url + '/' + str(zoomlevel) + '/' \
            + xdir + '/' + basename

    def fetch_or_download_maplet(self, path):
        """Return a pixbuf if the file is on disk, else (url, path)"""
        if not os.access(path, os.R_OK):
            if not self.download_url:
                if Debug:
                    print "Downloads not enabled; skipping", path
                return None

            # path is a full path on the local filesystem, OS independent.
            # We need to turn it into a url (Unix path) with slashes.
            thedir = os.path.dirname(path)
            if not os.access(thedir, os.W_OK):
                os.makedirs(thedir)
            return (self.url_from_path(path), path)

        try:
            pixbuf = gtk.gdk.pixbuf_new_from_file(path)
        except gobject.GError:
            pixbuf = None
            # return None

        # In case something went wrong, don't keep a bad file around:
        if not pixbuf or pixbuf.get_width() <= 0 or pixbuf.get_height() <= 0:
            print "Couldn't open pixbuf from", path
            os.rename(path, path + ".bad")

        return pixbuf

    def coords_to_filename(self, longitude, latitude):
        """Given coordinates in decimal degrees, map to the closest filename"""
        return None

    def get_top_left(self):
        """Get the coordinates of the top left corner of the map."""
        return None, None

class GenericMapCollection(TiledMapCollection):

    """
    A GenericMapCollection is tiled, like the Topo collections,
    but uses a less specific naming scheme:
    prefix-nn-mm.ext, with or without the dashes.
    """

    def __init__(self, _name, _location, _prefix, _ext,
                 _left_long, _top_lat,
                 _img_width, _img_height, _xscale, _yscale,
                 _numdigits, _usedash, _latfirst):
        """arguments:
        name       -- user-visible name of the collection
        location   -- directory on disk where the maps reside
        prefix     -- initial part of each maplet filename
        ext        -- filename extension including the dot, e.g. .jpg
        left_long  -- longitude of the left edge
        top_lat    -- latitude of the top edge
        img_width  -- width of each maplet in pixels
        img_height -- height of each maplet in pixels
        xscale     -- pixels per degree longitude
        yscale     -- pixels per degree latitude
        numdigits  -- number of digits in x and y file specifiers
        usedash    -- Boolean, use a dash between x and y in filenames?
        latfirst   -- Boolean, is latitude the first of the two numbers?

        """
        TiledMapCollection.__init__(self, _name, _location,
                                    _img_width, _img_height, )
        self.prefix = _prefix
        self.numdigits = _numdigits
        self.usedash = _usedash
        self.ext = _ext
        self.latfirst = _latfirst
        self.img_width = _img_width
        self.img_height = _img_height
        self.left_longitude = _left_long    # Left of 00-00 image
        self.top_latitude = _top_lat        # Top of 00-00 image
        self.xscale = float(_xscale)        # Pixels per degree
        self.yscale = float(_yscale)        # Pixels per degree

    def get_maplet(self, longitude, latitude):
        """Get the maplet containing the specified coordinates.
        Returns pixbuf, x_offset, y_offset, filename
        where offsets are pixels from top left of the specified coords
        and pixbuf or (less often) filename may be None.
        """
        filename = self.coords_to_filename(longitude, latitude)
        if (Debug):
            print "Generic get_maplet", longitude, latitude, "->", filename
        if filename == None or not os.access(filename, os.R_OK):
            #print "Can't open", filename, "for", longitude, latitude
            return None, 0, 0, filename
        #print "Opened", filename, "for", longitude, latitude
        pixbuf = gtk.gdk.pixbuf_new_from_file(filename)

        # Offsets aren't implemented yet:
        x_off = 0
        y_off = 0

        return pixbuf, x_off, y_off, filename

    def get_next_maplet(self, fullpathname, dX, dY):
        """Given a maplet's pathname, get the next or previous one.
        Does not currently work for jumps more than 1 in any direction.
        Returns pixbuf, newpath (either may be None).
        """
        pathname, filename = os.path.split(fullpathname)
        if (Debug):
            print "Generic get_next_maplet", filename, dX, dY
        name, ext = os.path.splitext(filename)
        #traceback.print_stack()
        mapb = int(name[-self.numdigits:])
        if self.usedash:
            mapa = int(name[-self.numdigits*2 - 1 : -self.numdigits-1])
        else:
            mapa = int(name[-self.numdigits*2 : -self.numdigits])
        if self.latfirst:
            newa = MapUtils.ohstring(mapa + dX, self.numdigits)
            newb = MapUtils.ohstring(mapb + dY, self.numdigits)
        else:
            newa = MapUtils.ohstring(mapa + dY, self.numdigits)
            newb = MapUtils.ohstring(mapb + dX, self.numdigits)
        if self.usedash:
            newname = self.prefix + newa + "-" + newb
        else:
            newname = self.prefix + newa + newb
        newpath = os.path.join(self.location, newname + ext)
        if filename == None or not os.access(filename, os.R_OK):
            return None, newpath
        pixbuf = gtk.gdk.pixbuf_new_from_file(newpath)
        return pixbuf, newpath

    def coords_to_filename(self, longitude, latitude):
        """Given coordinates in decimal degrees, map to the closest filename"""
        if self.left_longitude > longitude or self.top_latitude < latitude:
            return None
        x_grid = MapUtils.intTrunc((longitude - self.left_longitude) *
                                   self.xscale / self.img_width)
        y_grid = MapUtils.intTrunc((self.top_latitude - latitude) *
                                   self.yscale / self.img_height)
        if not self.latfirst:
            temp = x_grid
            x_grid = y_grid
            y_grid = temp
        retstr = os.path.join(self.location,
                              self.prefix + MapUtils.ohstring(x_grid,
                                                              self.numdigits))
        if self.usedash:
            retstr = retstr + "-"
        retstr = retstr + MapUtils.ohstring(y_grid, self.numdigits) + self.ext
        return retstr

    def get_top_left(self):
        """Get the coordinates of the top left corner of the map."""
        return self.left_longitude, self.top_latitude

class TopoMapCollection(TiledMapCollection):

    """TiledMapCollections using the Topo! map datasets.
    Filenames are named according to a fairly strict convention.
    Some variants can toggle between more than one scale (series).
    """

    def __init__(self, _name, _location, _series, _tile_w, _tile_h,
                 _ser7prefix="012t", _ser15prefix="024t", _img_ext=".gif"):
        """arguments:
        name        -- user-visible name of the collection
        location    -- directory on disk where the maps reside
        series      -- initial series to use, 7.5 or 15 minutes of arc.
        tile_w      -- width of each maplet in pixels
        tile_h      -- height of each maplet in pixels
        img_ext     -- filename extension including the dot, e.g. .jpg
        ser7prefix  -- prefix for tile files implementing the 7.5-min series
        ser15prefix -- prefix for tile files implementing the 15-min series
        """

        TiledMapCollection.__init__(self, _name, _location, _tile_w, _tile_h)
        self.set_series(_series)
        self.ser7prefix = _ser7prefix
        self.ser15prefix = _ser15prefix
        self.img_ext = _img_ext

        # _correction because Topo1 maps aren't in WGS 84.
        # Right now these numbers are EMPIRICAL and inaccurate.
        # Need to do them right!
        # http://www.ngs.noaa.gov/cgi-bin/nadcon.prl says the correction
        # in the Mojave area from NAD27 to NAD84 (nobody converts to
        # WGS84, alas) should be -0.05463', 2.99014' (-1.684m, 75.554m)
        self.lon_correction = 0 # 0.032778 / 1000
        self.lat_correction = 0 # -1.794084 / 1000

    def set_series(self, _series):
        """Set the series to either 7.5 or 15 minutes."""

        #traceback.print_stack()
        self.series = _series
        self.xscale = self.img_width * 600.0 / self.series
        self.yscale = self.img_height * 600.0 / self.series
        if (Debug):
            print "set series to", self.series
        # 600 is minutes/degree * maplets/minute

        # The fraction of a degree that each maplet spans:
        self.frac = float(self.img_width) / self.xscale
        if (Debug):
            if self.frac != float(self.img_height) / self.yscale:
                print "x and y fractions not equal!",
                print self.frac, float(self.img_height) / self.yscale

    def get_maplet(self, longitude, latitude):
        """Get the maplet containing the specified coordinates.
        Returns pixbuf, x_offset, y_offset, filename
        where offsets are pixels from top left of the specified coords
        and pixbuf or (less often) filename may be None.
        """

        filename = self.coords_to_filename(longitude - self.lon_correction,
                                         latitude - self.lat_correction)
        if (Debug):
            print "T1MC get_maplet(", MapUtils.DecDegToDegMinStr(longitude),
            print  ",", MapUtils.DecDegToDegMinStr(latitude), "):", filename

        # Calculate offsets.
        # Maplets are self.series minutes wide and tall,
        # so any offset from that is an offset into the maplet:
        # the number of pixels in X and Y that have to be added
        # to get from the maplet's upper left corner to the
        # indicated coordinates.
        # But then we have to correct to get to WGS84 coordinates.
        # XXX the WGS84 part doesn't work right yet.

        # longitude increases rightward:
        x_off = int((longitude - MapUtils.TruncateToFrac(longitude, self.frac)
                     - self.lon_correction) * self.xscale)
        if (Debug):
            print "truncated", MapUtils.DecDegToDegMinStr(longitude), "to",
            print MapUtils.DecDegToDegMinStr(MapUtils.TruncateToFrac(longitude,
                                                                     self.frac))

        # Latitude decreases downward:
        y_off = int((MapUtils.TruncateToFrac(latitude, self.frac) +
                     self.frac - latitude - self.lat_correction) * self.yscale)

        if (Debug):
            print "truncated", MapUtils.DecDegToDegMinStr(latitude), "to",
            print MapUtils.DecDegToDegMinStr(MapUtils.TruncateToFrac(latitude,
                                                                     self.frac))
            print "y_off is", y_off

        if not os.access(filename, os.R_OK):
            return None, x_off, y_off, filename
        pixbuf = gtk.gdk.pixbuf_new_from_file(filename)

        return pixbuf, x_off, y_off, filename

    def get_next_maplet(self, fullpathname, dX, dY):
        """Given a maplet's pathname, get the next or previous one.
        Does not currently work for jumps more than 1 in any direction.
        Returns pixbuf, newpath (either may be None).
        """

        if (Debug):
            print "get_next_maplet:", fullpathname, dX, dY
        pathname, filename = os.path.split(fullpathname)
        collecdir, mapdir = os.path.split(pathname)
        maplat = mapdir[1:3]
        maplon = mapdir[3:6]
        name, ext = os.path.splitext(filename)
        xdir = int(mapdir[-1])
        ydir = ord(mapdir[-2]) - ord('a')     # ydir is a letter a-h
        if self.series == 7.5:
            serstr = self.ser7prefix
            grid = 10
        else:
            serstr = self.ser15prefix
            grid = 5

        x = int(name[-4:-2]) + dX
        y = int(name[-2:]) + dY

        if x < 1:
            x = grid
            xdir = xdir + 1
            if xdir > 8:
                xdir = 1
                if Debug:
                    print mapdir, name, ": wrapping mapdir coordinates -x",
                    print maplon
                maplon = str(int(maplon) + 1)
        if x > grid:
            x = 1
            xdir = xdir - 1
            if xdir < 1:
                xdir = 8
                if Debug:
                    print mapdir, name, ": wrapping mapdir coordinates +x",
                    print maplon
                maplon = str(int(maplon) - 1)

        if y > grid:
            y = 1
            ydir = ydir - 1
            if ydir < 0:
                ydir = 7
                if Debug:
                    print mapdir, name, ": wrapping mapdir coordinates +y",
                    print maplat
                maplat = str(int(maplat) - 1)

        if y < 1:
            y = grid
            ydir = ydir + 1
            if ydir > 7:
                ydir = 0
                if Debug:
                    print mapdir, name, ": wrapping mapdir coordinates -y",
                    print maplat
                maplat = str(int(maplat) + 1)

        # We're ready to piece the filename back together!
        newpath = os.path.join(collecdir,
                               "q" + MapUtils.ohstring(maplat, 2) \
                                   + MapUtils.ohstring(maplon, 3) \
                                   + chr(ydir + ord('a')) + str(xdir),
                               serstr + MapUtils.ohstring(x, 2) \
                                   + MapUtils.ohstring(y, 2) + ext)
        if not os.access(newpath, os.R_OK):
            if Debug:
                print "get_next_maplet(", fullpathname, dX, dY, ")"
                print "  Can't open", newpath
            return None, newpath

        pixbuf = gtk.gdk.pixbuf_new_from_file(newpath)
        return pixbuf, newpath

    #
    # Quirk: Topo1 collections are numbered with WEST longitude --
    # i.e. longitude is written as positive but it's actually negative.
    #
    # Second quirk: Topo1 collections aren't in the WGS 84 coordinate
    # system used by GPS receivers, and need to be translated.
    # http://en.wikipedia.org/wiki/Geographic_coordinate_system
    # http://en.wikipedia.org/wiki/Geodetic_system
    #
    def coords_to_filename(self, longitude, latitude):
        """Given a pair of coordinates in deg.mmss, map to the
        containing filename, e.g. q37122c2/012t0501.gif.
        """

        latDeg = MapUtils.intTrunc(latitude)
        longDeg = MapUtils.intTrunc(-longitude)
        latMin = (latitude - latDeg ) * 60.
        longMin = (-longitude - longDeg) * 60.

        # The 7.5 here is because of the 7.5 in the directory names above
        # (we're getting the offset of this image from the origin of
        # the 7.5-series map covered by the directory),
        # not the map series we're actually plotting now.
        longMinOrd = MapUtils.intTrunc(longMin / 7.5)
        latMinOrd = MapUtils.intTrunc(latMin / 7.5)

        dirname = "q" + MapUtils.ohstring(latDeg, 2) \
            + MapUtils.ohstring(longDeg, 3) \
            + chr(ord('a') + latMinOrd) + str(longMinOrd+1)

        # Find the difference between our desired coordinates
        # and the origin of the map this directory represents.
        # The 7.5 here is because of the 7.5 in the directory names above.
        latMinDiff = latMin - (latMinOrd * 7.5)
        longMinDiff = longMin - (longMinOrd * 7.5)

        latOffset = MapUtils.intTrunc(latMinDiff * 10 / self.series)
        longOffset = MapUtils.intTrunc(longMinDiff * 10 / self.series)

        # Now calculate the current filename.
        # Note that series is either 7.5 or 15
        if (self.series > 13):
            fileprefix = "024t"
            numcharts = 5
        else:
            fileprefix = "012t"
            numcharts = 10
        filename = fileprefix + MapUtils.ohstring(numcharts-longOffset, 2) + \
                   MapUtils.ohstring(numcharts-latOffset, 2) + self.img_ext

        return self.location + "/" + dirname + "/" + filename

    def dir_to_latlong(self, qdir):
        """Given a directory, figure out the corresponding coords."""
        letter = ord(qdir[6]) - ord('a')
        digit = int(qdir[7]) - 1
        thislon = -int(qdir[3:6]) + (digit * 7.5 * 1.5 / 60)
        #thislon += self.lon_correction
        thislat = int(qdir[1:3]) + (letter * 7.5 * 1.5 / 60)
        #thislat += self.lat_correction
        return thislon, thislat

    def get_top_left(self):
        """Get the coordinates of the top left corner of the map."""
        minlong = 181
        maxlat = -91
        topleftdir = None

        mapdirs = os.listdir(self.location)
        # mapdirs.sort()
        for mapdir in mapdirs:
            if mapdir[0] == 'q':
                # Now first_mapdir is some name like "qAAABBcD" ... decode it.
                thislong, thislat = self.dir_to_latlong(mapdir)
                #if thislong < minlong and thislat > maxlat:
                if thislong < minlong:
                    minlong = thislong
                    if thislat > maxlat:
                        maxlat = thislat
                        topleftdir = mapdir
        if maxlat < -90 or minlong > 180:
            return 0, 0    # shouldn't happen

        # Now we have the top left directory. Still need the top left file:
        files = os.listdir(os.path.join(self.location, topleftdir))

        return minlong, maxlat

# End of TopoMapCollection class

class Topo1MapCollection(TopoMapCollection):

    """
Topo1MapCollection: data from local-area Topo! packages,
  the kind that have 7.5 minute and 15 minute varieties included.
   (self, _name, _location, _series, tile_w, tile_h):
    """

    def __init__(self, _name, _location, _series, _tile_w, _tile_h):
        TopoMapCollection.__init__(self, _name, _location, _series,
                                   _tile_w, _tile_h,
                                   _ser7prefix="012t", _ser15prefix="024t",
                                   _img_ext=".gif")

    def zoom(self, amount, latitude=45):
        if self.series == 7.5 and amount < 0:
            self.set_series(15)
        elif self.series == 15 and amount > 0:
            self.set_series(7.5)

# A Topo2MapCollection is just a Topo1MapCollection that has only
# 7.5-series and has a different file prefix.
# On North Palisade 7.5 (q37118a5) we get 410x256 pixel images.
class Topo2MapCollection(TopoMapCollection):

    """
Topo2MapCollection: data from local-area Topo! packages that
  have only the 7.5-minute series and use jpg instead of gif.
   (collection_name, directory_path, file_prefix, tile_w, tile_h):
    """

    def __init__(self, _name, _location, _prefix, _tile_w, _tile_h):
        TopoMapCollection.__init__(self, _name, _location, 7.5,
                                   _tile_w, _tile_h,
                                   _ser7prefix=_prefix, _ser15prefix=None,
                                   _img_ext=".jpg")

class TrackPoints:

    """Parsing and handling of GPS track files.
    Currently only GPX format is supported.
    """

    # A special variable to indicate the start of a track,
    # in case a track doesn't have a name.
    START = "start"

    def __init__(self):
        self.points = []
        self.waypoints = []
        self.minlon = 361
        self.maxlon = -361
        self.minlat = 91
        self.maxlat = -91

    def get_bounds(self):
        return self.minlon, self.minlat, self.maxlon, self.maxlat

    def is_start(self, point):
        '''Is this the start of a new track segment?
           If so, it's a string (or unicode),
           either the name of the track section
           or the special string TrackPoints.START.
        '''
        return (isinstance(point, str) or isinstance(point, unicode))

    def handleTrackPoint(self, lat, lon, ele, waypoint_name=False):
        '''Add a new trackpoint or waypoint after some basic sanity checks.
           If waypoint_name, we assume this is a waypoint,
           otherwise assume it's a track point.
        '''
        if lon < self.minlon:
            self.minlon = lon
        if lon > self.maxlon:
            self.maxlon = lon
        if lat < self.minlat:
            self.minlat = lat
        if lat > self.maxlat:
            self.maxlat = lat

        if (waypoint_name):
            self.waypoints.append([lon, lat, waypoint_name])
        else:
            self.points.append([lon, lat])

    def readTrackFile(self, filename):
        """Read a track file. Throw IOError if the file doesn't exist."""
        if filename.lower().endswith('.kml') or \
           filename.lower().endswith('.kmz'):
            return self.readTrackFileKML(filename)
        return self.readTrackFileGPX(filename)

    def readTrackFileGPX(self, filename):
        """Read a GPX track file. Throw IOError if the file doesn't exist."""
        global Debug

        if not os.path.exists(filename):
            raise IOError("Can't open track file %s" % filename)

        if (Debug):
            print "Using track file", filename

        if (Debug):
            print "Reading track file", filename
        dom = xml.dom.minidom.parse(filename)

        # Handle track(s).
        segs = dom.getElementsByTagName("trkseg")
        for seg in segs:
            trkpts = seg.getElementsByTagName("trkpt")

            # need to keep different track files and segments separate -- don't
            # draw lines from the end of one track to the beginning of the next.
            if trkpts:
                # See if the parent track has a name.
                trk = seg
                while trk.nodeName != "trk":
                    trk = trk.parentNode
                trkname = trk.getElementsByTagName("name")
                if trkname and \
                   trkname[0].hasChildNodes() and \
                   trkname[0].firstChild.nodeName == '#text' and \
                   trkname[0].firstChild.wholeText:
                    self.points.append(trkname[0].firstChild.wholeText)
                else:
                    self.points.append(TrackPoints.START)

                for pt in trkpts:
                    # self.handleTrackPointGPX(pt, False)
                    lat, lon, ele, time = self.GPX_point_coords(pt)
                    self.handleTrackPoint(lat, lon, ele, None)

        # Handle waypoints
        waypts = dom.getElementsByTagName("wpt")
        if waypts:
            self.waypoints.append(TrackPoints.START)
            for pt in waypts:
                lat, lon, ele, time = self.GPX_point_coords(pt)
                name = "WP"
                n = pt.getElementsByTagName("name")
                if len(n) > 0:
                    n = n[0].childNodes
                    if len(n) >= 1 and n[0].nodeType == n[0].TEXT_NODE:
                        name = n[0].data
                self.handleTrackPoint(lat, lon, ele, name)

        # GPX also allows for routing, rtept, but I don't think we need those.

    def GPX_point_coords(self, point):
        '''Add a new trackpoint or waypoint from a GPX node'''
        lat = float(point.getAttribute("lat"))
        lon = float(point.getAttribute("lon"))
        #ele = float(getVal(point, "ele"))
        #ele = round(ele * 3.2808399, 2)      # convert from meters to feet
        #time = getVal(point, "time")
        return lat, lon, 0, 0

    def readTrackFileKML(self, filename):
        """Read a KML track file.
           Just read Placemarks (which cover both paths and points);
           ignore all styles.
           Throw IOError if the file doesn't exist.
        """
        global Debug

        if not os.path.exists(filename):
            raise IOError("Can't open track file %s" % filename)

        if (Debug):
            print "Reading track file", filename

        # Handle kmz compressed files, which are much more common in practice
        # than actual KML files:
        if filename.lower().endswith(".kmz") and zipfile.is_zipfile(filename):
            zip = zipfile.ZipFile(filename)
            namelist = zip.namelist()
            if "doc.kml" not in namelist:
                raise ValueError("No doc.kml in %s" % filename)
            if len(namelist) > 1:
                print "Warning: ignoring files other than doc.kml in", filename
            kmlfp = zip.open("doc.kml")
            doc_kml = kmlfp.read()
            kmlfp.close()
            dom = xml.dom.minidom.parseString(doc_kml)
            doc_kml = None
        else:
            dom = xml.dom.minidom.parse(filename)

        # Features we care about are <Placemark> containing either
        # <LineString> (tracks) or <Point> (waypoints).
        # A Placemark also contains <name>The name</name>.
        # Placemarks are apparently grouped inside a <Document>
        # but let's not worry about that now.

        placemarks = dom.getElementsByTagName("Placemark")
        for placemark in placemarks:
            # Handle tracks:
            linestrings = placemark.getElementsByTagName("LineString")
            for linestring in linestrings:
                coord_triples = self.get_KML_coordinates(linestring)
                if not coord_triples:
                    continue
                self.points.append(TrackPoints.START)
                for triple in coord_triples:
                    self.handleTrackPoint(triple[1], triple[0], triple[2], None)

            # Handle waypoints:
            try:
                name = placemark.getElementsByTagName("name")[0].childNodes[0].data.strip()
                if not name:
                    name = "WP"
            except:
                # print "Couldn't get name:", placemark.toprettyxml()
                name = "wp"
            points = placemark.getElementsByTagName("Point")
            for point in points:
                coord_triples = self.get_KML_coordinates(point)
                for triple in coord_triples:
                    self.handleTrackPoint(triple[1], triple[0], triple[2], name)

    def get_KML_coordinates(self, el):
        '''From inside an element of a KML file, get the contents
           of the first <coordinates> triple.
           Return a list of triples [[lat, lon, ele], [lat, lon, ele] ...]
        '''
        coords = el.getElementsByTagName("coordinates")
        if not coords or len(coords) < 1:
            return None
        coord_triples = coords[0].childNodes[0].data.strip().split(' ')
        ret = []
        for s in coord_triples:
            triple = s.split(',')
            ret.append(map(float, triple))

        return ret

class MapUtils:

    """MapUtils really just exists to contain a bunch of utility
       functions useful for mapping classes.
    """

    @classmethod
    def coord2str_dd(cls, lon, lat):
        """Convert a longitude, latitude pair into a pretty string,
           in decimal degrees"""
        s = "%.7f E  " % lon
        if lat >= 0:
            s += "%.7f N" % lat
        else:
            s += "%.57 S" % -lat
        return s

    @classmethod
    def DegMinToDecDeg(cls, coord):
        """Convert degrees.minutes to decimal degrees"""
        deg = cls.intTrunc(coord)
        dec = (coord - deg) / .6
        return deg + dec

    @classmethod
    def DecDegToDegMin(cls, coord):
        """Convert decimal degrees to degrees.minutes"""
        if coord < 0:
            sgn = -1
            coord = -coord
        else:
            sgn = 1
        deg = cls.intTrunc(coord)
        min = abs(coord - deg) * .6
        return sgn * (deg + min)

    @classmethod
    def DecDegToDegMinStr(cls, coord):
        """Convert decimal degrees to a nice degrees/minutes string"""
        if coord < 0:
            sgnstr = '-'
            coord = -coord
        else:
            sgnstr = ''
        deg = cls.intTrunc(coord)
        min = abs(coord - deg) * 60.
        min = cls.TruncateToFrac(min, .01)
        return sgnstr + str(deg) + "^" + str(min) + "'"

    @classmethod
    def angle_to_bearing(cls, angle):
        return (450 - angle) % 360

    # Convert an angle (deg) to the appropriate quadrant string, e.g. N 57 E.
    @classmethod
    def angle_to_quadrant(cls, angle):
        if angle > 180:
            angle = angle - 360
        if angle == 0:
            return "N"
        if angle == -90:
            return "W"
        if angle == 90:
            return "E"
        if angle == 180:
            return "S"
        if angle > -90 and angle < 90:
            if angle < 0:
                return "N " + str(-angle) + " W"
            return "N " + str(angle) + " E"
        if angle < 0:
            return "S " + str(180 + angle) + " W"
        return "S " + str(180 - angle) + " E"

    @classmethod
    def intTrunc(cls, num):
        """Truncate to an integer, but no .999999 stuff"""
        return int(num + .00001)

    @classmethod
    def TruncateToFrac(cls, num, frac):
        """Truncate to a multiple of the given fraction"""
        t = float(MapUtils.intTrunc(num / frac)) * frac
        if num < 0:
            t = t - frac
        return t

    @classmethod
    def ohstring(cls, num, numdigits):
        """Return a zero-prefixed string of the given number of digits."""
        fmt = '%%0%d' % numdigits
        return fmt % num

    @classmethod
    def haversine_distance(cls, latitude_1, longitude_1,
                                latitude_2, longitude_2):
        """
        Haversine distance between two points, expressed in meters.
        From https://github.com/tkrajina/gpxpy/blob/master/gpxpy/geo.py
        Implemented from http://www.movable-type.co.uk/scripts/latlong.html
        """
        d_lat = math.radians(latitude_1 - latitude_2)
        d_lon = math.radians(longitude_1 - longitude_2)
        lat1 = math.radians(latitude_1)
        lat2 = math.radians(latitude_2)

        a = math.sin(d_lat/2) * math.sin(d_lat/2) + \
            math.sin(d_lon/2) * math.sin(d_lon/2) * \
            math.cos(lat1) * math.cos(lat2)
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        EARTH_RADIUS = 3959.     # miles
        d = EARTH_RADIUS * c

        return d

    @classmethod
    def distance_on_unit_sphere(cls, lat1, long1, lat2, long2):
        '''Linear distance between two points on a globe, in km.
           Divide by 1.609 to get miles.
        '''
        # Thanks http://www.johndcook.com/blog/python_longitude_latitude/

        # Convert latitude and longitude to 
        # spherical coordinates in radians.
        degrees_to_radians = math.pi/180.0

        # phi = 90 - latitude
        phi1 = (90.0 - lat1)*degrees_to_radians
        phi2 = (90.0 - lat2)*degrees_to_radians

        # theta = longitude
        theta1 = long1*degrees_to_radians
        theta2 = long2*degrees_to_radians

        # Compute spherical distance from spherical coordinates.

        # For two locations in spherical coordinates 
        # (1, theta, phi) and (1, theta', phi')
        # cosine( arc length ) = 
        #    sin phi sin phi' cos(theta-theta') + cos phi cos phi'
        # distance = rho * arc length

        cos = (math.sin(phi1)*math.sin(phi2)*math.cos(theta1 - theta2) + 
               math.cos(phi1)*math.cos(phi2))
        arc = math.acos( cos )

        # Remember to multiply arc by the radius of the earth 
        # in your favorite set of units to get length.
        return arc * 6373

# End of "MapUtils" pseudo-class.

class DownloadTileQueue:
    def __init__(self):
        self.queue = []    # Will be a list

    def __len__(self):
        return len(self.queue)

    def push(self, url, path, x, y, x_off, y_off, mapwin):
        """Push details for a new tile onto the queue if not already there,
           or replace XY info if already there -- the map must have moved.
        """
        for q in self.queue:
            if q[1] == path :  # Are paths the same?
                # Replace XY info
                q[2] = x
                q[3] = y
                q[4] = x_off
                q[5] = y_off
                return
        if path:
            self.queue.insert(0, [url, path, x, y, x_off, y_off, mapwin])

    def pop(self):
        return self.queue.pop()

    def peek(self):
        return self.queue[-1]

class MapWindow():

    """The PyTopo UI: the map window.
This is intended to hold the GTK specific drawing code,
and to be extensible into other widget libraries.
To that end, it needs to implement the following methods
that are expected by the MapCollection classes:
   win_width, win_height = get_size(), set_color(),
   draw_pixbuf(pixbuf, x_off, y_off, x, y, w, h)
   draw_rectangle(fill, x, y, width, height)
   draw_line(x, y, width, height)
"""

    def __init__(self, _controller):
        """Initialize variables, but don't create the window yet."""

        # Save a reference to the PyTopo object that created this window.
        # We'll need it to change locations, collections etc.
        self.controller = _controller

        # The current map collection being used:
        self.collection = None

        self.center_lon = 0
        self.center_lat = 0
        self.cur_lon = 0
        self.cur_lat = 0
        self.trackpoints = None
        self.show_waypoints = True
        self.selected_track = None

        try:
            self.pin = \
                gtk.gdk.pixbuf_new_from_file("/usr/share/pytopo/pytopo-pin.png")
        except:
            try:
                self.pin = gtk.gdk.pixbuf_new_from_file("pytopo-pin.png")
            except:
                self.pin = None
        self.pin_lon = 0
        self.pin_lat = 0
        self.pin_xoff = -4
        self.pin_yoff = -12

        # Print distances in metric?
        # This should be set externally!
        self.use_metric = False

        # Where to save generated maps. The default is fine for most people.
        # Which is a good thing since there's currently no way to change it.
        self.map_save_dir = os.path.expanduser("~/Topo/")

        # X/gtk graphics variables we need:
        self.drawing_area = 0
        self.xgc = 0

        self.click_last_long = 0
        self.click_last_lat = 0
        self.is_dragging = False

        # The timeout for long press events
        self.press_timeout = None

        # Colors and fonts should of course be configurable:
        # self.bg_color = gtk.gdk.color_parse("black")
        self.black_color = gtk.gdk.color_parse("black")
        self.red_color = gtk.gdk.color_parse("red")
        self.bg_scale_color = gtk.gdk.color_parse("white")
        self.first_track_color = gtk.gdk.color_parse("magenta")
        self.waypoint_color = gtk.gdk.color_parse("blue2")
        self.grid_color = gtk.gdk.color_parse("grey45")

        self.font_desc = pango.FontDescription("Sans 9")
        self.wpt_font_desc = pango.FontDescription("Sans Italic 10")
        self.select_font_desc = pango.FontDescription("Sans Bold 15")

    def show_window(self, init_width, init_height):
        """Create the initial window."""
        win = gtk.Window()
        win.set_name("PyTopo")
        win.connect("destroy", self.graceful_exit)
        win.set_border_width(5)

        vbox = gtk.VBox(spacing=3)
        win.add(vbox)

        self.drawing_area = gtk.DrawingArea()
        # This sets the window's initial size -- but also makes it the minimum
        # size. How do we set initial size without constraining minimum?
        self.drawing_area.set_size_request(init_width, init_height)
        vbox.pack_start(self.drawing_area)

        self.drawing_area.set_events(gtk.gdk.EXPOSURE_MASK |
                                     gtk.gdk.POINTER_MOTION_MASK |
                                     gtk.gdk.POINTER_MOTION_HINT_MASK |
                                     gtk.gdk.BUTTON_PRESS_MASK |
                                     gtk.gdk.BUTTON_RELEASE_MASK )

        self.drawing_area.connect("expose-event", self.expose_event)
        self.drawing_area.connect("button-press-event", self.mousepress)
        self.drawing_area.connect("button-release-event", self.mouserelease)
        self.drawing_area.connect("scroll-event", self.scroll_event)
        self.drawing_area.connect("motion_notify_event", self.drag_event)

        # The default focus in/out handlers on drawing area cause
        # spurious expose events.  Trap the focus events, to block that:
        # XXX can we pass "pass" in to .connect?
        self.drawing_area.connect("focus-in-event", self.nop)
        self.drawing_area.connect("focus-out-event", self.nop)

        # Handle key presses on the drawing area.
        # If seeing spurious expose events, try setting them on win instead,
        # and comment out gtk.CAN_FOCUS.
        self.drawing_area.set_flags(gtk.CAN_FOCUS)
        self.drawing_area.connect("key-press-event", self.key_press_event)

        win.show_all()
        gtk.main()

    #
    # Draw maplets to fill the window, centered at center_lon, center_lat
    #
    def draw_map(self):
        """Redraw the map, centered at center_lon, center_lat."""
        global Debug

        if self.collection == None:
            print "No collection!"
            return
        if not self.drawing_area:
            # Not initialized yet, not ready to draw a map
            return

        self.win_width, self.win_height = self.drawing_area.window.get_size()

        # XXX Collection.draw_map wants center, but we only have lower right.
        if (Debug):
            print ">>>>>>>>>>>>>>>>"
            print "window draw_map centered at",
            print MapUtils.DecDegToDegMinStr(self.center_lon),
            print MapUtils.DecDegToDegMinStr(self.center_lat)
        self.collection.draw_map(self.center_lon, self.center_lat, self)

        self.draw_trackpoints()

        if not self.is_dragging:
            self.draw_zoom_control()

        # Is there a selected track?
        if self.selected_track:
            trackname = self.trackpoints.points[self.selected_track]
            tracklabel = "Selected track: " + trackname

            label_margin = 15
            layout = self.drawing_area.create_pango_layout(tracklabel)
            layout.set_font_description(self.select_font_desc)
            label_width, label_height = layout.get_pixel_size()
            self.xgc.set_rgb_fg_color(self.red_color)
            self.drawing_area.window.draw_layout(self.xgc,
                                                 self.win_width - label_width - label_margin,
                                                 label_margin,
                                                 layout)
            # self.draw_string_scale(self.win_width - label_width - label_margin,
            #                        label_margin,
            #                        tracklabel)

        # draw pin
        pin_x, pin_y = self.coords2xy(self.pin_lon, self.pin_lat,
                                      self.win_width, self.win_height)

        if self.pin:
            self.draw_pixbuf(self.pin, 0,0,pin_x+self.pin_xoff,
                             pin_y+self.pin_yoff,-1,-1)

        self.draw_map_scale()

    def contrasting_color(self, color):
        '''Takes a gtk.gdk.Color (RGB values 0:65535)
            and converts it to a similar saturation and value but different hue
        '''
        if not color:
            return self.first_track_color;

        # Hue is a floating point between 0 and 1. How much should we jump?
        jump = .37

        return gtk.gdk.color_from_hsv(color.hue + jump,
                                      color.saturation, color.value)

    def draw_trackpoint_segment(self, start, linecolor, linewidth=3,
                                linestyle=gtk.gdk.LINE_ON_OFF_DASH):
        '''Draw a trackpoint segment, starting at the given index.
           Stop drawing if we reach another START, and return the index
           of that START. Return None if we reach the end of the list.
        '''
        self.set_color(linecolor)
        self.xgc.line_style = linestyle
        self.xgc.line_width = linewidth
        cur_x = None
        cur_y = None
        i = start
        if self.trackpoints.is_start(self.trackpoints.points[i]):
            # This should be true
            i += 1

        while True:
            if i >= len(self.trackpoints.points):
                return None
            pt = self.trackpoints.points[i]
            if self.trackpoints.is_start(pt):
                return i
            i += 1

            x = int((pt[0] - self.center_lon) * self.collection.xscale
                    + self.win_width/2)
            y = int((self.center_lat - pt[1]) * self.collection.yscale
                    + self.win_height/2)

            if ((x >= 0 and x < self.win_width and
                 y >= 0 and y < self.win_height) or
                (cur_x < self.win_width and cur_y < self.win_height)):
                if cur_x != None and cur_y != None:
                    # self.set_color(self.track_color)
                    self.draw_line(cur_x, cur_y, x, y)
                    # self.set_color(self.black_color)
                    # self.draw_circle(True, x, y, 3)

                cur_x = x
                cur_y = y
            else:
                # It's off the screen. Skip it.
                #print "Skipping", pt[0], pt[1], \
                #    ": would be", x, ",", y
                cur_x = None
                cur_y = None

    def select_track(self, trackindex):
        if Debug:
            print "Selecting track starting at", trackindex
        self.selected_track = trackindex
        # self.draw_trackpoint_segment(trackindex, self.red_color, linewidth=6)
        self.draw_map()

    def draw_trackpoints(self):
        # Now draw any trackpoints that are visible:
        self.track_color = None
        if self.trackpoints != None :   # may be trackpoints or waypoints
            # win_width, win_height = self.drawing_area.window.get_size()
            if len(self.trackpoints.points) > 0:
                cur_x = None
                cur_y = None

                next = 0
                while True:
                    self.track_color = self.contrasting_color(self.track_color)
                    next = self.draw_trackpoint_segment(next, self.track_color)
                    if not next:
                        break

            if self.selected_track != None:  # Could be trackpoint 0
                self.draw_trackpoint_segment(self.selected_track,
                                             self.red_color, linewidth=6)

            if self.show_waypoints and len(self.trackpoints.waypoints) > 0:
                self.set_color(self.waypoint_color)
                self.xgc.line_style = gtk.gdk.LINE_SOLID
                self.xgc.line_width = 2
                for pt in self.trackpoints.waypoints:
                    if self.trackpoints.is_start(pt):
                        continue
                    x = int((pt[0] - self.center_lon) * self.collection.xscale
                            + self.win_width/2)
                    y = int((self.center_lat - pt[1]) * self.collection.yscale
                            + self.win_height/2)

                    if x >= 0 and x < self.win_width and \
                       y >= 0 and y < self.win_height:
                        layout = self.drawing_area.create_pango_layout(pt[2])
                        layout.set_font_description (self.wpt_font_desc)
                        # tw = layout.get_size()[0] / pango.SCALE
                        th = layout.get_size()[1] / pango.SCALE
                        self.drawing_area.window.draw_layout(self.xgc,
                                                             x + th/3,
                                                             y - th/2,
                                                             layout)
                        self.draw_rectangle(True, x-3, y-3, 6, 6)

    def draw_map_scale(self):
        ########################################################################
        #
        # The draw_map_scale function calculates and draws a map scale at the
        # bottom of the map window created by the PyTopo mapping application.
        # Distances are calculated along the surface of the geoid defined by the
        # earth equitorial radius, Req, and the square of the eccentricity of
        # the earth, esq.
        # The map scale is accurate only for the center latitude of the map.
        # The circumference of the earth at the equator is 24901 miles (an upper
        # limit on map size).
        # USGS quadrangles use NAD-27, but WGS-84 is the most recent datum, and
        # GPS uses WGS-84.
        #
        # References:
        #    http://en.wikipedia.org/wiki/Geodetic_system
        #    http://www.gmat.unsw.edu.au/snap/gps/clynch_pdfs/radiigeo.pdf
        #
        # Copyright (C) 2013 Spencer A. Buckner
        #
        ########################################################################

        # Define constants
        # Req = 6.3781370e+06   # WGS-84 earth equatorial radius (meters)
        # esq = 6.694380e-03    # WGS-84 square of eccentricity of earth
        Req = 6.3782064e+06   # NAD-27 earth equatorial radius (meters)
        esq = 6.768658e-03    # NAD-27 square of eccentricity of earth

        # Calculate pixels per mile and pixels per kilometer at map center
        lat_deg = self.center_lat
        lat_rad = lat_deg*math.pi/180
        sin_lat = math.sin(lat_rad)
        sin_lat_sq = sin_lat*sin_lat
        cos_lat = math.cos(lat_rad)
        R_meters = Req/math.sqrt(1 - esq*sin_lat_sq)             # earth radius (m)
        R_miles = R_meters/(0.0254*12*5280)                      # earth radius (miles)
        R_km = R_meters/1000	                                   # earth radius (km)
        xscale_deg = self.collection.xscale                      # pixels per degree
        xscale_mi = xscale_deg*360/(2*math.pi*R_miles*cos_lat)   # pixels per mile
        xscale_km = xscale_deg*360/(2*math.pi*R_km*cos_lat)      # pixels per km

        ##################################################

        # Calculate window width in miles and kilometers
        width_mi = self.win_width/xscale_mi   # (miles)
        width_km = self.win_width/xscale_km   # (kilometers)

        # Calculate length of map-scale bars in pixels;
        # length (pixels) <= self.win_width/2.
        log_width = math.log10(width_mi/2)
        power_10 = math.floor(log_width)
        fraction = log_width - power_10
        log10_1 = 0
        log10_2 = math.log10(2)
        log10_5 = math.log10(5)
        log10_10 = 1
        if log10_1 <= fraction and fraction < log10_2:
            length = 1*math.pow(10, power_10)   # (miles or kilometers)
            nticks = 6
        elif log10_2 <= fraction and fraction < log10_5:
            length = 2*math.pow(10, power_10)   # (miles or kilometers)
            nticks = 5
        elif log10_5 <= fraction and fraction < log10_10:
            length = 5*math.pow(10, power_10)   # (miles or kilometers)
            nticks = 6
        length_mi = xscale_mi*length   # (pixels)
        length_km = xscale_km*length   # (pixels)
        label_mi = str(10)
        label_km = str(10)
        label_mi = '\0'*len(label_mi)
        label_km = '\0'*len(label_km)
        label_mi = "%g mi" %length
        label_km = "%g km" %length

        ##################################################

        # Calculate coordinates of miles map-scale bar
        x1 = int((self.win_width - length_mi)/2 + 0.5)
        y1 = int(self.win_height - 30 + 0.5)
        x2 = int(x1 + length_mi + 0.5)
        y2 = y1

        # Get label length in pixels;
        # length of "0" string is 7.
        layout = self.drawing_area.create_pango_layout (label_mi)
        layout.set_font_description (self.font_desc)
        width, height = layout.get_pixel_size ()
        str_length_mi = width

        # Draw white background for miles map-scale
        self.xgc.line_style = gtk.gdk.LINE_SOLID
        self.set_color(self.bg_scale_color)
        self.xgc.line_width = 20
        self.draw_line(x1-10-7-10, y1, x2+10+str_length_mi+10, y2)

        # Draw miles map-scale bar
        self.set_bg_color()
        self.xgc.line_width = 1
        self.draw_line(x1, y1, x2, y2)

        # Draw tick marks on miles map-scale bar
        x0 = x1
        for i in range(nticks):
            x1 = x0 + int(i*length_mi/(nticks - 1) + 0.5)
            x2 = x1
            self.draw_line(x1, y1-3, x2, y2+3)

        # Draw miles map-scale labels
        x = x0 - 10 - 7
        y = self.win_height - 36
        self.draw_string_scale(x, y, "0")
        x = x2 + 10
        self.draw_string_scale(x, y, label_mi)

        ##################################################

        # Calculate coordinates of kilometers map-scale bar
        x1 = int((self.win_width - length_km)/2 + 0.5)
        y1 = int(self.win_height - 10 + 0.5)
        x2 = int(x1 + length_km + 0.5)
        y2 = y1

        # Get label length in pixels;
        # length of "0" string is 7.
        layout = self.drawing_area.create_pango_layout (label_km)
        layout.set_font_description (self.font_desc)
        width, height = layout.get_pixel_size ()
        str_length_km = width

        # Draw white background for kilometers map-scale
        self.xgc.line_style = gtk.gdk.LINE_SOLID
        self.set_color(self.bg_scale_color)
        self.xgc.line_width = 20
        self.draw_line(x1-10-7-10, y1, x2+10+str_length_km+10, y2)

        # Draw kilometers map-scale bar
        self.set_bg_color()
        self.xgc.line_width = 1
        self.draw_line(x1, y1, x2, y2)

        # Draw tick marks on kilometers map-scale bar
        x0 = x1
        for i in range(nticks):
            x1 = x0 + int(i*length_km/(nticks - 1) + 0.5)
            x2 = x1
            self.draw_line(x1, y1-3, x2, y2+3)

        # Draw kilometers map-scale labels
        x = x0 - 10 - 6
        y = self.win_height - 16
        self.draw_string_scale(x, y, "0")
        x = x2 + 10
        self.draw_string_scale(x, y, label_km)

    def draw_zoom_control(self):
        """Draw some zoom controls in case we're running on a tablet
           and have no keyboard to zoom or move around.
           Also draw any other controls we might need.
        """
        self.zoom_btn_size = int(self.win_width / 25)
        self.zoom_X1 = 8
        self.zoom_in_Y1 = 10
        self.zoom_out_Y1 = self.zoom_in_Y1 + self.zoom_btn_size * 2
        textoffset = self.zoom_btn_size / 5

        self.xgc.line_style = gtk.gdk.LINE_SOLID
        self.set_color(self.grid_color)
        self.xgc.line_width = 3

        # Draw the boxes
        self.draw_rectangle(False, self.zoom_X1, self.zoom_in_Y1,
                            self.zoom_btn_size, self.zoom_btn_size)
        self.draw_rectangle(False, self.zoom_X1, self.zoom_out_Y1,
                            self.zoom_btn_size, self.zoom_btn_size)

        midpointx = self.zoom_X1 + self.zoom_btn_size/2
        # Draw the -
        midpointy = self.zoom_out_Y1 + self.zoom_btn_size/2
        self.draw_line(self.zoom_X1 + textoffset, midpointy,
                       self.zoom_X1 + self.zoom_btn_size - textoffset,
                       midpointy)

        # Draw the +
        midpointy = self.zoom_in_Y1 + self.zoom_btn_size/2
        self.draw_line(self.zoom_X1 + textoffset, midpointy,
                       self.zoom_X1 + self.zoom_btn_size - textoffset,
                       midpointy)
        self.draw_line(midpointx, self.zoom_in_Y1 + textoffset,
                       midpointx,
                       self.zoom_in_Y1 + self.zoom_btn_size - textoffset)

    def was_click_in_zoom(self, x, y):
        """Do the coordinates fall within the zoom in or out buttons?
           Returns 0 for none, 1 for zoom in, -1 for zoom out.
        """
        if x < self.zoom_X1 or x > self.zoom_X1 + self.zoom_btn_size:
            return 0
        if y < self.zoom_in_Y1 or y > self.zoom_out_Y1 + self.zoom_btn_size:
            return 0
        if y < self.zoom_in_Y1 + self.zoom_btn_size:
            return 1
        if y > self.zoom_out_Y1:
            return -1
        # Must be between buttons
        return 0

    def print_location(self, widget=None):
        print MapUtils.coord2str_dd(self.cur_lon, self.cur_lat)
        print "%-15s %-15s" % (MapUtils.DecDegToDegMinStr(self.cur_lon),
                             MapUtils.DecDegToDegMinStr(self.cur_lat))

    def zoom(self, widget=None):
        self.center_lon = self.cur_lon
        self.center_lat = self.cur_lat
        self.collection.zoom(1)
        self.draw_map()

    def scroll_event(self, button, event):
        if event.direction != gtk.gdk.SCROLL_UP and \
           event.direction != gtk.gdk.SCROLL_DOWN:
            return False

        if event.direction == gtk.gdk.SCROLL_UP:
            direc = 1
        else:
            direc = -1

        # Save off the coordinates currently under the mouse,
        # so we can arrange for it to be under the mouse again after zoom.
        curmouselon, curmouselat = self.xy2coords(event.x, event.y,
                                                  self.win_width,
                                                  self.win_height)

        self.collection.zoom(direc)

        # What are the coordinates for the current mouse pos after zoom?
        newmouselon, newmouselat = self.xy2coords(event.x, event.y,
                                                  self.win_width,
                                                  self.win_height)
        # Shift the map over so the old point will be under the mouse.
        self.center_lon += (curmouselon - newmouselon)
        self.center_lat += (curmouselat - newmouselat)

        self.draw_map()
        return True

    def context_menu(self, event):
        '''Create a context menu. This is called anew on every right-click.'''

        contextmenu = collections.OrderedDict([
            ( MapUtils.coord2str_dd(self.cur_lon, self.cur_lat),
              self.print_location),
            ( "Zoom here...", self.zoom),
            ( "Go to pin...", self.set_center_to_pin),
            ( "Pin this location", self.set_pin_by_mouse),
            ( "Save pin location...", self.save_location),
            ( "My Locations...", self.mylocations),
            ( "My Tracks...", self.mytracks),
            ( "Download Area...", self.download_area),
            ( "Show waypoints...", self.toggle_show_waypoints),
            ( "Change background map", self.change_collection),
            ( "Quit", self.graceful_exit)
            ])

        menu = gtk.Menu()
        for itemname in contextmenu.keys():
            item = gtk.MenuItem(itemname)

            # Show/Hide waypoints changes its name since it's a toggle:
            if contextmenu[itemname] == self.toggle_show_waypoints:
                if self.show_waypoints:
                    item.set_label("Hide waypoints...")
                item.connect("activate", contextmenu[itemname])

            # Change background map gives a submenu of available collections.
            elif itemname == "Change background map":
                submenu = gtk.Menu()
                for coll in self.controller.collections:
                    subitem = gtk.MenuItem(coll.name)
                    subitem.connect("activate", self.change_collection,
                                    coll.name)
                    submenu.append(subitem)
                    subitem.show()
                item.set_submenu(submenu)

            elif contextmenu[itemname]:
                item.connect("activate", contextmenu[itemname])

            # Would be nice to make the menu item not selectable,
            # but this greys it out and makes it hard to read.
            # else:
            #     item.set_sensitive(False)

            menu.append(item)
            item.show()

        if event:
            button = event.button
            t = event.time
        else:
            button = 3
            t = 0
            # There's no documentation on what event.time is: it's
            # "the time of the event in milliseconds" -- but since when?
            # Not since the epoch.
        menu.popup(None, None, None, button, t)

    def change_collection(self, widget, name):
        newcoll = self.controller.find_collection(name)
        if newcoll:
            newcoll.zoom_to(self.collection.zoomlevel, self.cur_lat)
            self.collection = newcoll
            self.draw_map()
        else:
            print "Couldn't find a collection named '%s'" % name

    def toggle_show_waypoints(self, widget):
        self.show_waypoints = not self.show_waypoints
        self.draw_map()

    def mylocations(self, widget):
        self.controller.location_select(self)

    def set_pin_by_mouse(self, widget):
        """Set the pin at the current mouse location"""
        self.pin_lon, self.pin_lat = self.cur_lon, self.cur_lat
        self.draw_map()

    def set_center_to_pin(self, widget):
        """Set the center at the current pin point"""
        self.center_lon, self.center_lat = self.pin_lon, self.pin_lat
        self.draw_map()

    def save_location(self, widget):
        """Save the pinned location.
        XXX should save zoom level too, if different from collection default.
        """
        dialog = gtk.Dialog("Save location", None, 0,
                            (gtk.STOCK_CANCEL, gtk.RESPONSE_NONE,
                             gtk.STOCK_OK, gtk.RESPONSE_OK))
        dialog.set_size_request(200, 150)
        dialog.vbox.set_spacing(10)

        prompt = gtk.Label("Please specify a name:")
        dialog.vbox.pack_start(prompt, expand=False)
        nametext = gtk.Entry()
        dialog.vbox.pack_start(nametext, expand=True)
        comment = gtk.Label("")
        dialog.vbox.pack_start(comment, expand=False)

        dialog.show_all()

        while True:
            response = dialog.run()
            if response == gtk.RESPONSE_OK:
                name = nametext.get_text().strip()
                if not name:
                    comment.set_text("Name can't be empty")
                    continue

                # Add to KnownSites
                self.controller.append_known_site( [name,
                    MapUtils.DecDegToDegMin(self.pin_lon),
                    MapUtils.DecDegToDegMin(self.pin_lat),
                    self.collection.name,
                    self.collection.zoomlevel] )

                dialog.destroy()
                return True
            else:
                dialog.destroy()
                return True

    def mytracks(self, widget):
        self.controller.TrackSelect(self)
        if self.trackpoints != None:
            self.trackpoints_center()
        self.draw_map()

    def trackpoints_center(self):
        minlon, minlat, maxlon, maxlat = self.trackpoints.get_bounds()
        self.center_lon = (maxlon + minlon) / 2
        self.center_lat = (maxlat + minlat) / 2

    def cancel_download(self, widget, data=None):
        self.cancelled = True

    def download_area(self, widget):
        global Debug
        if not self.collection.zoomlevel:
            print "Can't download an area for this collection"
            return

        # Get default values for area and zoom levels:
        halfwidth = self.win_width / self.collection.xscale / 2
        halfheight = self.win_height / self.collection.yscale / 2
        minlon = self.center_lon - halfwidth
        maxlon = self.center_lon + halfwidth
        minlat = self.center_lat - halfheight
        maxlat = self.center_lat + halfheight
        minzoom = self.collection.zoomlevel
        maxzoom = self.collection.zoomlevel + 4

        # Prompt the user for any adjustments to area and zoom:
        dialog = gtk.Dialog("Download an area", None, 0,
                            (gtk.STOCK_REFRESH, gtk.RESPONSE_APPLY,
                             gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                             gtk.STOCK_OK, gtk.RESPONSE_OK))
        #dialog.set_size_request(200, 150)
        #dialog.vbox.set_spacing(10)
        frame = gtk.Frame("Current zoom = %d" % self.collection.zoomlevel)
        dialog.vbox.pack_start(frame, True, True, 0)
    
        table = gtk.Table(4, 3, False)
        table.set_border_width(5)
        table.set_row_spacings(5)
        table.set_col_spacings(10)
        frame.add(table)

        label = gtk.Label("Min longitude:")
        label.set_justify(gtk.JUSTIFY_RIGHT)
        table.attach(label, 0, 1, 0, 1,
                     gtk.SHRINK, 0, 0, 0)
        minlon_entry = gtk.Entry()
        table.attach(minlon_entry, 1, 2, 0, 1,
                     gtk.EXPAND | gtk.FILL, 0, 0, 0)

        label = gtk.Label("Max longitude:")
        label.set_justify(gtk.JUSTIFY_RIGHT)
        table.attach(label, 2, 3, 0, 1,
                     gtk.SHRINK, 0, 0, 0)
        maxlon_entry = gtk.Entry()
        table.attach(maxlon_entry, 3, 4, 0, 1,
                     gtk.EXPAND | gtk.FILL, 0, 0, 0)

        label = gtk.Label("Min latitude:")
        label.set_justify(gtk.JUSTIFY_RIGHT)
        table.attach(label, 0, 1, 1, 2,
                     gtk.SHRINK, 0, 0, 0)
        minlat_entry = gtk.Entry()
        table.attach(minlat_entry, 1, 2, 1, 2,
                     gtk.EXPAND | gtk.FILL, 0, 0, 0)

        label = gtk.Label("Max latitude:")
        label.set_justify(gtk.JUSTIFY_RIGHT)
        table.attach(label, 2, 3, 1, 2,
                     gtk.SHRINK, 0, 0, 0)
        maxlat_entry = gtk.Entry()
        table.attach(maxlat_entry, 3, 4, 1, 2,
                     gtk.EXPAND | gtk.FILL, 0, 0, 0)

        label = gtk.Label("Min zoom:")
        label.set_justify(gtk.JUSTIFY_RIGHT)
        table.attach(label, 0, 1, 2, 3,
                     gtk.SHRINK, 0, 0, 0)
        minzoom_entry = gtk.Entry()
        table.attach(minzoom_entry, 1, 2, 2, 3,
                     gtk.EXPAND | gtk.FILL, 0, 0, 0)

        label = gtk.Label("Max zoom:")
        label.set_justify(gtk.JUSTIFY_RIGHT)
        table.attach(label, 2, 3, 2, 3,
                     gtk.SHRINK, 0, 0, 0)
        maxzoom_entry = gtk.Entry()
        table.attach(maxzoom_entry, 3, 4, 2, 3,
                     gtk.EXPAND | gtk.FILL, 0, 0, 0)

        err_label = gtk.Label("")
        dialog.vbox.pack_start(err_label, True, True, 0)

        progress_label = gtk.Label("")
        dialog.vbox.pack_start(progress_label, True, True, 0)

        def flush_events():
            while gtk.events_pending():
                gtk.main_iteration(False)

        def reset_download_dialog():
            minlon_entry.set_text(str(minlon))
            maxlon_entry.set_text(str(maxlon))
            minlat_entry.set_text(str(minlat))
            maxlat_entry.set_text(str(maxlat))
            minzoom_entry.set_text(str(minzoom))
            maxzoom_entry.set_text(str(maxzoom))

        reset_download_dialog()

        dialog.show_all()

        self.cancelled = False

        while True:
            response = dialog.run()
            if response == gtk.RESPONSE_CANCEL:
                dialog.destroy()
                return True
            if response == gtk.RESPONSE_APPLY:
                reset_download_dialog()
                continue
            # Else the response must have been OK.
            # So connect the cancel button to cancel_download(),
            # which means first we have to find the cancel button:
            # Starting with PyGTK 2.22 we can use this easier method:
            #cancelBtn = dialog.get_widget_for_response(gtk.RESPONSE_OK)
            # but for now:
            buttons = dialog.get_action_area().get_children()
            for b in buttons:
                if b.get_label() == 'gtk-cancel':
                    b.connect("clicked", self.cancel_download, str)
                    break

            try:
                minlon = float(minlon_entry.get_text().strip())
                maxlon = float(maxlon_entry.get_text().strip())
                minlat = float(minlat_entry.get_text().strip())
                maxlat = float(maxlat_entry.get_text().strip())
                minzoom = int(minzoom_entry.get_text().strip())
                maxzoom = int(maxzoom_entry.get_text().strip())
                break

            except ValueError:
                err_label.set_text("Sorry, can't parse one of the values")
                continue

        if Debug:
            print "Downloading from %f - %f, %f - %f, zoom %d - %d" \
                % (minlon, maxlon, minlat, maxlat, minzoom, maxzoom)
        for zoom in range(minzoom, maxzoom+1):
            err_label.set_text("Downloading zoom level %d" % zoom)

            # Show a busy cursor on the dialog:
            busy_cursor = gtk.gdk.Cursor(gtk.gdk.WATCH)
            dialog.window.set_cursor(busy_cursor)
            flush_events()
            gtk.gdk.flush()

            if Debug:
                print "==== Zoom level", zoom

            # Find the start and end tiles
            (minxtile, minytile, x_off, y_off) = \
                self.collection.deg2num(maxlat, minlon, zoom)
            (maxxtile, maxytile, x_off, y_off) = \
                self.collection.deg2num(minlat, maxlon, zoom)
            if Debug:
                print "X tiles from", minxtile, "to", maxxtile
                print "Y tiles from", minytile, "to", maxytile

            pathlist = []
            for ytile in range(minytile, maxytile+1):
                for xtile in range(minxtile, maxxtile+1):
                    if Debug:
                        print "Tile", xtile, ytile,
                    filename = os.path.join(self.collection.location,
                                            str(zoom),
                                            str(xtile),
                                            str(ytile)) \
                                            + self.collection.ext
                    if os.access(filename, os.R_OK):
                        if Debug:
                            print filename, "is already there"
                        continue
                    pathlist.append(filename)
                    if Debug:
                        print "appended as", filename

            numtiles = len(pathlist)
            err_label.set_text("Zoom level %d: %d tiles" % (zoom, numtiles))
            flush_events()
            num_downloaded = 0

            for filename in pathlist:
                if self.cancelled:
                    dialog.destroy()
                    return True

                url = self.collection.url_from_path(filename, zoom)

                # XXX Parallelize this!
                if Debug:
                    print "Downloading", url, "to", filename
                thedir = os.path.dirname(filename)
                if not os.access(thedir, os.W_OK):
                    os.makedirs(thedir)
                #err_label.set_text("%d %%: %d of %d" % \
                #                   (int(num_downloaded*100 / numtiles),
                #                    num_downloaded, numtiles))
                if Debug:
                    print "%d %%: %d of %d" % \
                        (int(num_downloaded*100 / numtiles),
                         num_downloaded, numtiles)
                progress_label.set_text("%d: %s" % (num_downloaded, url))
                flush_events()
                urllib.urlretrieve(url, filename)
                num_downloaded += 1

                # XXX should show progress more graphically.

        dialog.destroy()
        return True

    #
    # Drawing-related routines:
    #

    def get_size(self):
        """Return the width and height of the canvas."""
        return self.drawing_area.window.get_size()

    def set_bg_color(self):
        """Change to the normal background color (usually black)."""
        #self.xgc.set_rgb_fg_color(self.bg_color)
        self.xgc.foreground = self.xgc.background

    def set_color(self, color):
        self.xgc.set_rgb_fg_color(color)

    def draw_pixbuf(self, pixbuf, x_off, y_off, x, y, w, h):
        """Draw the pixbuf at the given position and size,
        starting at the specified offset."""
        self.drawing_area.window.draw_pixbuf(self.xgc, pixbuf, x_off, y_off,
                                              x, y, w, h)
    def draw_rectangle(self, fill, x, y, w, h):
        """Draw a rectangle."""
        self.drawing_area.window.draw_rectangle(self.xgc, fill, x, y, w, h)

    def draw_line(self, x, y, x2, y2):
        """Draw a line."""
        self.drawing_area.window.draw_line(self.xgc, x, y, x2, y2)

    def draw_circle(self, fill, xc, yc, r):
        """Draw a circle, filled or not, centered at xc, yc with radius r."""
        self.drawing_area.window.draw_arc(self.xgc, fill, xc-r, yc-4,
                                          r*2, r*2, 0, 23040)  # 64 * 360

    def draw_string_scale(self, x, y, s):
        """Draw a string."""
        layout = self.drawing_area.create_pango_layout(s)
        layout.set_font_description (self.font_desc)
        self.drawing_area.window.draw_layout(self.xgc, x, y, layout)

    # Save the current map as something which could be gimped or printed.
    # XXX THIS IS BROKEN, code assumes start_lon/start_lat but has center_.
    def save_as(self):

        """Save a static map. Somewhat BROKEN, needs rewriting."""

        file_list = ""

        # Calculate dAngle in decimal degrees
        dAngle = self.collection.img_width / self.collection.xscale

        # Calculate number of charts based on window size, and round up
        # so the saved map shows at least as much as the window does.
        num_lon = int (.8 + float(self.win_width) / self.collection.img_width)
        num_lat = int (.8 + float(self.win_height) / self.collection.img_height)

        ny = 0
        curlat = self.center_lat + dAngle*num_lat * .25
        while ny < num_lat:
            curlon = self.center_lon - dAngle*num_lon * .25
            nx = 0
            while nx < num_lon:
                file_list += " " + \
                    self.collection.coords_to_filename(curlon, curlat)
                curlon += dAngle
                nx += 1
            curlat -= dAngle
            ny += 1

        outfile = self.map_save_dir + "topo" + "_" + \
                  str(self.center_lon) + "_" + str(self.center_lat) + ".gif"
        cmdstr = "montage -geometry 262x328 -tile " + \
                 str(nx) + "x" + str(ny) + " " + \
                 file_list + " " + outfile
        #print "Running:", cmdstr
        os.system(cmdstr)

        if (os.access(outfile, os.R_OK)):
            print "Saved:", outfile

    def expose_event(self, widget, event):
        """Handle exposes on the canvas."""
        #print "Expose:", event.type, "for object", self
        #print "area:", event.area.x, event.area.y, \
        #    event.area.width, event.area.height

        if self.xgc == 0:
            self.xgc = self.drawing_area.window.new_gc()
            #self.xgc.set_foreground(white)

        #x, y, w, h = event.area

        self.draw_map()

        return True

    def key_press_event(self, widget, event):
        """Handle any key press."""
        if event.string == "q":
            self.graceful_exit()
            # Must return here ... gtk.main_quit() (called from graceful_exit())
            # won't actually return immediately, so without a return
            # we'll fall through and end up drawing the map again
            # before exiting.
            return True
        elif event.string == "+" or event.string == "=":
            self.collection.zoom(1)
        elif event.string == "-":
            self.collection.zoom(-1)
        elif event.keyval == gtk.keysyms.Left:
            self.center_lon -= \
                float(self.collection.img_width) / self.collection.xscale
        elif event.keyval == gtk.keysyms.Right:
            self.center_lon += \
                float(self.collection.img_width) / self.collection.xscale
        elif event.keyval == gtk.keysyms.Up:
            self.center_lat += \
                float(self.collection.img_height) / self.collection.yscale
        elif event.keyval == gtk.keysyms.Down:
            self.center_lat -= \
                float(self.collection.img_height) / self.collection.yscale
        elif event.keyval == gtk.keysyms.space:
            self.set_center_to_pin()
        elif event.keyval == gtk.keysyms.l and \
                 event.state == gtk.gdk.CONTROL_MASK:
            pass    # Just fall through to draw_map()
        elif event.string == "m":
            if PyTopo.selection_window(p, self):
                self.set_center_to_pin()
                pass
        elif event.string == "s":
            self.save_as()
            return True
        else:
            #print "Unknown key,", event.keyval
            return False

        self.draw_map()
        return True

    def xy2coords(self, x, y, win_width, win_height, xscale=None, yscale=None):
        """Convert pixels to longitude/latitude."""
        # collection.x_scale is in pixels per degree.
        if not xscale:
            xscale = self.collection.xscale
        if not yscale:
            yscale = self.collection.yscale
        return (self.center_lon - \
                    float(win_width/2 - x) / xscale,
                self.center_lat + \
                    float(win_height/2 - y) / yscale)

    def coords2xy(self, lon, lat, win_width, win_height,
                  xscale=None, yscale=None):
        """Convert lon/lat to pixels."""
        if not xscale:
            xscale = self.collection.xscale
        if not yscale:
            yscale = self.collection.yscale
        return (int((lon - self.center_lon) * xscale
                    + win_width/2),
                int((self.center_lat - lat) * yscale
                    + win_height/2) )

    def drag_event(self, widget, event):
        """Move the map as the user drags."""

        if self.press_timeout:
            gobject.source_remove(self.press_timeout)
            self.press_timeout = None

        # On a tablet (at least the ExoPC), almost every click registers
        # as a drag. So if a drag starts in the zoom control area,
        # it was probably really meant to be a single click.
        if self.was_click_in_zoom(event.x, event.y):
            return False

        # The GTK documentation @ 24.2.1
        # http://www.pygtk.org/pygtk2tutorial/sec-EventHandling.html
        # says the first event is a real motion event and subsequent
        # ones are hints; but in practice, nothing but hints are
        # ever sent.
        if event.is_hint:
            x, y, state = event.window.get_pointer()
        else:
            x = event.x
            y = event.y
            state = event.state
        if not state & gtk.gdk.BUTTON1_MASK:
            return False
        if not self.is_dragging:
            self.x_start_drag = x
            self.y_start_drag = y
            self.is_dragging = True
        self.move_to(x, y, widget)
        return True

    def move_to(self, x, y, widget):
        if widget.drag_check_threshold(self.x_start_drag, self.y_start_drag,
                                       x, y):
            dx = x - self.x_start_drag
            dy = y - self.y_start_drag
            self.center_lon -= dx / self.collection.xscale
            self.center_lat += dy / self.collection.yscale
            self.draw_map()
            # Reset the drag coordinates now that we're there
            self.x_start_drag = x
            self.y_start_drag = y

    def mousepress(self, widget, event):
        """Handle mouse button presses"""

        # We're either about to add a new timeout, or not time out
        # because we had a doubleclick. Either way, remove any
        # existing timeout:
        if self.press_timeout:
            gobject.source_remove(self.press_timeout)
            self.press_timeout = None

        # Was it a right click?
        if event.button == 3:
            x, y, state = self.drawing_area.window.get_pointer()
            self.cur_lon, self.cur_lat = self.xy2coords(x, y,
                                                        self.win_width,
                                                        self.win_height)
            self.context_menu(event)
            return

        # If it wasn't a double click, set a timeout for LongPress
        if event.type != gtk.gdk._2BUTTON_PRESS:
            self.press_timeout = gobject.timeout_add(1000, self.longpress)
            return False

        # Zoom in if we get a double-click.
        self.center_lon, self.center_lat = self.xy2coords(event.x, event.y,
                                           self.win_width, self.win_height)

        self.collection.zoom(1)
        self.draw_map()
        return True

    def longpress(self):
        if self.press_timeout:
            gobject.source_remove(self.press_timeout)
            self.press_timeout = None
        x, y, state = self.drawing_area.window.get_pointer()
        self.cur_lon, self.cur_lat = self.xy2coords(x, y,
                                                    self.win_width,
                                                    self.win_height)
        self.context_menu(None)
        return True

    def mouserelease(self, widget, event):
        """Handle button releases."""

        if self.press_timeout:
            gobject.source_remove(self.press_timeout)
            self.press_timeout = None
            #return False

        if self.is_dragging:
            self.is_dragging = False
            x, y, state = event.window.get_pointer()
            self.move_to(x, y, widget)
            self.draw_zoom_control()
            return True

        if event.button == 1:
            global Debug

            zoom =  self.was_click_in_zoom(event.x, event.y)
            if zoom:
                self.collection.zoom(zoom)
                self.draw_map()
                return True

            cur_long, cur_lat = self.xy2coords(event.x, event.y,
                                               self.win_width, self.win_height)
            if Debug:
                print "Click:", \
                    MapUtils.DecDegToDegMinStr(cur_long), \
                    MapUtils.DecDegToDegMinStr(cur_lat)

            # Find angle and distance since last click.
            if Debug or event.state & gtk.gdk.SHIFT_MASK:
                if self.click_last_long != 0 and self.click_last_lat != 0:
                    dist = MapUtils.distance_on_unit_sphere(self.click_last_lat,
                                                           self.click_last_long,
                                                            cur_lat, cur_long)
                    dist2 = MapUtils.haversine_distance(self.click_last_lat,
                                                           self.click_last_long,
                                                            cur_lat, cur_long)
                    if self.use_metric:
                        print "Distance: %.2f km" % dist
                    else:
                        print "Distance: %.2f mi" % (dist / 1.609)
                        print "Haversine Distance: %.2f mi" % dist2

                    # Now calculate bearing. I don't know how accurate this is.
                    xdiff = (cur_long - self.click_last_long)
                    ydiff = (cur_lat - self.click_last_lat)
                    angle = int(math.atan2(-ydiff, -xdiff) * 180 / math.pi)
                    angle = MapUtils.angle_to_bearing(angle)
                    print "Bearing:", angle, "=", \
                        MapUtils.angle_to_quadrant(angle)
            self.click_last_long = cur_long
            self.click_last_lat = cur_lat

            # Is the click near a track or waypoint we're displaying?
            halfwidth, halfheight = \
                      [ x/2 for x in self.drawing_area.window.get_size()]
            CLOSE = 7    # pixels

            if self.trackpoints != None and self.trackpoints.waypoints != None:
                for i, pt in enumerate(self.trackpoints.waypoints):
                    if self.trackpoints.is_start(pt):
                        continue
                    tx = int((pt[0] - self.center_lon) * self.collection.xscale
                             + halfwidth)
                    ty = int((self.center_lat - pt[1]) * self.collection.yscale
                             + halfheight)
                    if abs(event.x - tx) < CLOSE and \
                       abs(event.y - ty) < CLOSE:
                        print "Clicked on waypoint #", i
                        return

            if self.trackpoints != None and len(self.trackpoints.points) > 0:
                for i, pt in enumerate(self.trackpoints.points):
                    if self.trackpoints.is_start(pt):
                        track_start = i
                        lastx = None
                        lasty = None
                        continue

                    tx = int((pt[0] - self.center_lon) * self.collection.xscale
                             + halfwidth)
                    ty = int((self.center_lat - pt[1]) * self.collection.yscale
                             + halfheight)
                    if abs(event.x - tx) < CLOSE and \
                       abs(event.y - ty) < CLOSE:
                        self.select_track(track_start)
                        return
                    # Okay, the click wasn't on a point. Is it on
                    # a line between this point and the last one?
                    if lastx and lasty:
                        m = float(y-lasty) / float(x-lastx)
                        y1 = m * event.x + lasty  # Predicted position
                        if abs(event.y - y1) < CLOSE:
                            self.select_track(track_start)
                            return

            # If we didn't select any tracks or anything, we might
            # have selected some earlier, in which case we want to
            # redraw them now.
            if (self.selected_track):
                self.select_track(None)

        return True

    @staticmethod
    def nop(*args):
        "Do nothing."
        return True

    def graceful_exit(self, extra=None):
        """Clean up the window and exit.
           The "extra" argument is so it can be calld from GTK callbacks.
        """
        self.controller.save_sites() # Tell PyTopo to save any new sites/tracks

        gtk.main_quit()
        # The python profilers don't work if you call sys.exit here.

        # Too bad, because gtk.main_quit() doesn't actually exit
        # until later. So any function that calls this must be sure
        # to guard against anything like extra map redraws.
#
# End of MapWindow class
#

class PyTopo:

    """A class to hold the mechanics of running the PyTopo program,
    plus some important variables including Collections and KnownSites.
    """

    def __init__(self):
        self.collections = []
        self.KnownSites = []
        self.KnownTracks = []
        self.init_width = 800
        self.init_height = 600
        self.default_collection = None
        self.needs_saving = False
        self.config_dir = os.path.expanduser("~/.config/pytopo",)
        self.savefilename = os.path.join(self.config_dir, "saved.sites")

    @classmethod
    def Usage(cls):
        global VersionString
        print VersionString
        print """
Usage: pytopo [-t trackfile] [-c collection] [site_name]
       pytopo [-t trackfile] start_lat start_long collection
       pytopo -p : list known sites and tracks
       pytopo -h : print this message

Use degrees.decimal_minutes format for coordinates.
Set up site names in ~/.config/pytopo.sites, track logs in ~/Tracks.

Track files may contain track points and/or waypoints;
multiple track files are allowed.

Move around using arrow keys.  q quits.
Click in the map to print the coordinates of the clicked location.
's' will attempt to save the current map as a GIF file in ~/Topo/."""
        sys.exit(1)

    @classmethod
    def error_out(cls, errstr):
        """Print an error and exit cleanly."""
        print "==============="
        print errstr
        print "===============\n"
        PyTopo.Usage()

    def append_known_site(self, site):
        self.KnownSites.append(site)
        self.needs_saving = True

    def save_sites(self):
        """Write any new KnownSites to file.
           Should only be called from graceful exit.
        """
        if not self.needs_saving:
            return

        try:
            savefile = open(self.savefilename, "w")
        except:
            print "Couldn't open save file", self.savefilename
            return

        for site in self.KnownSites[self.first_saved_site:]:
            # All sites have a string, two floats and another string;
            # some sites may have additional ints after that.
            print >>savefile, '[ "%s", %f, %f, "%s"' % \
                (site[0], site[1], site[2], site[3]),
            if len(site) > 4:
                print >>savefile, ', ' + ', '.join(map(str, site[4:])),
            print >>savefile, "]"
        savefile.close()

    def print_sites(self):
        """Print the list of known sites."""
        print "Known Sites:"
        for site in self.KnownSites:
            print " ", site[0], "(", os.path.basename(site[3]), ")"
        print
        print "Known Tracks:"
        for track in self.KnownTracks:
            print " ", track[0]
        sys.exit(0)

    def find_collection(self, collname):
        """Find a collection with the given name."""
        global Debug

        #print "Looking for a collection named", collname
        # Make sure collname is a MapCollection we know about:
        collection = None
        for coll in self.collections:
            if collname == coll.name:
                if not coll.exists():
                    PyTopo.error_out("Can't access location " + coll.location +
                                     " for collection " + collname)
                collection = coll
                if (Debug):
                    print "Found the collection", collection.name
                return collection
        return collection

    def selection_window(self, mapwin):
        '''Show a window that lets the user choose a known starting point.
        '''
        dialog = gtk.Dialog("Choose a point", None, 0,
                            (gtk.STOCK_CLOSE, gtk.RESPONSE_NONE,
                             gtk.STOCK_OK, gtk.RESPONSE_OK))
        #dialog.connect('destroy', lambda win: gtk.main_quit())
        dialog.set_size_request(400, 300)

        sw = gtk.ScrolledWindow()
        sw.set_shadow_type(gtk.SHADOW_ETCHED_IN)
        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)

        # List store will hold name, collection-name and site object
        store = gtk.ListStore(str, str, object)

        # Create the list
        for site in self.KnownSites:
            store.append([site[0], site[3], site])

        # http://pygtk.org/pygtk2tutorial/ch-TreeViewWidget.html
        # Make a treeview from the list:
        treeview = gtk.TreeView(store)

        renderer = gtk.CellRendererText()
        column = gtk.TreeViewColumn("Location", renderer, text=0)
        #column.pack_start(renderer, True)
        #column.set_resizable(True)
        treeview.append_column(column)
        renderer = gtk.CellRendererText()
        column = gtk.TreeViewColumn("Collection", renderer, text=1)
        #column.pack_start(renderer, False)
        treeview.append_column(column)

        #store.set_sort_column_id(0, gtk.SORT_ASCENDING)

        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        sw.add(treeview)

        dialog.vbox.pack_start(sw, expand=True)

        dialog.show_all()

        response = dialog.run()
        if response == gtk.RESPONSE_OK:
            selection = treeview.get_selection()
            model, iter = selection.get_selected()
            if iter:
                #locname = store.get_value(iter, 0)
                #collname = store.get_value(iter, 1)
                site = store.get_value(iter, 2)
                self.use_site(site, mapwin)
                dialog.destroy()
                return True
        else:
            dialog.destroy()
        return False

    def TrackSelect(self, mapwin):
        dialog = gtk.Dialog("Tracks", None, 0,
                            (gtk.STOCK_CLOSE, gtk.RESPONSE_NONE,
                             gtk.STOCK_OK, gtk.RESPONSE_OK))
        dialog.set_size_request(400, 300)

        sw = gtk.ScrolledWindow()
        sw.set_shadow_type(gtk.SHADOW_ETCHED_IN)
        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)

        # List store will hold Track name and Track file path
        store = gtk.ListStore(str, str)

        # Create the list
        for track in self.KnownTracks:
            store.append([ track[0], track[1] ])

        treeview = gtk.TreeView(store)

        renderer = gtk.CellRendererText()
        column = gtk.TreeViewColumn("Track name", renderer, text=0)
        treeview.append_column(column)

        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        sw.add(treeview)

        dialog.vbox.pack_start(sw, expand=True)

        dialog.show_all()

        response = dialog.run()
        if response == gtk.RESPONSE_OK:
            selection = treeview.get_selection()
            model, iter = selection.get_selected()
            if iter:
                trackfile = store.get_value(iter, 1)
                mapwin.trackpoints = TrackPoints()
                mapwin.trackpoints.readTrackFile(trackfile)
                # XXX Might want to handle IOError in case file doesn't exist
                dialog.destroy()
                return True
        else:
            dialog.destroy()
        return False

    def location_select(self, mapwin):
        dialog = gtk.Dialog("Locations", None, 0,
                            (gtk.STOCK_REMOVE, gtk.RESPONSE_APPLY,
                             gtk.STOCK_CLOSE, gtk.RESPONSE_NONE,
                             gtk.STOCK_OK, gtk.RESPONSE_OK))
        dialog.set_size_request(400, 300)

        sw = gtk.ScrolledWindow()
        sw.set_shadow_type(gtk.SHADOW_ETCHED_IN)
        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)

        # List store will hold name, collection-name and site object
        store = gtk.ListStore(str, str, object)

        # Create the list
        for site in self.KnownSites:
            store.append([site[0], site[3], site])

        # Make a treeview from the list:
        treeview = gtk.TreeView(store)

        renderer = gtk.CellRendererText()
        column = gtk.TreeViewColumn("Location", renderer, text=0)
        treeview.append_column(column)
        renderer = gtk.CellRendererText()
        column = gtk.TreeViewColumn("Collection", renderer, text=1)
        treeview.append_column(column)

        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        sw.add(treeview)

        dialog.vbox.pack_start(sw, expand=True)

        dialog.show_all()

        response = dialog.run()
        while response == gtk.RESPONSE_APPLY:
            selection = treeview.get_selection()
            model, iter = selection.get_selected()
            if iter:
                site = store.get_value(iter, 2)
                self.KnownSites.remove(site)
                store.remove(iter)
            response = dialog.run()

        if response == gtk.RESPONSE_OK:
            selection = treeview.get_selection()
            model, iter = selection.get_selected()
            if iter:
                site = store.get_value(iter, 2)
                self.use_site(site, mapwin)
                dialog.destroy()
                return True
        else:
            dialog.destroy()
        return False

    def use_site(self, site, mapwin):
        collection = self.find_collection(site[3])
        if not collection:
            return False
        mapwin.collection = collection

        # site[1] and site[2] are the long and lat in deg.minutes
        #print site[0], site[1], site[2]
        mapwin.center_lon = MapUtils.DegMinToDecDeg(site[1])
        mapwin.center_lat = MapUtils.DegMinToDecDeg(site[2])
        mapwin.pin_lon = mapwin.center_lon
        mapwin.pin_lat = mapwin.center_lat
        #print "Center in decimal degrees:", centerLon, centerLat
        if (Debug):
            print site[0] + ":", \
                MapUtils.DecDegToDegMinStr(mapwin.center_lon), \
                MapUtils.DecDegToDegMinStr(mapwin.center_lat)
        if len(site) > 4 and collection.zoom_to:
            collection.zoom_to(site[4])
        mapwin.draw_map()
        return True

    def parse_args(self, mapwin, args):
        """Parse runtime arguments."""
        global VersionString
        global Debug

        # Variables we expect from .pytopo:
        do_collection = False

        arg0 = args[0]
        args = args[1:]

        while len(args) > 0:
            if args[0][0] == '-' and not args[0][1].isdigit():
                if args[0] == "-v" or args[0] == "--version":
                    print VersionString
                    sys.exit(0)
                elif args[0] == "-h" or args[0] == "--help":
                    PyTopo.Usage()

                # Next clause is impossible because of the prev isdigit check:
                #if args[0] == "-15":
                #    series = 15
                elif args[0] == "-p":
                    self.print_sites()
                elif args[0] == "-c":
                    # Specify a collection:
                    if len(args) < 2:
                        print "-c must specify collection"
                        PyTopo.Usage()
                    mapwin.collection = self.find_collection(args[1])
                    if mapwin.collection == None:
                        PyTopo.error_out("I can't find a map collection called "
                                        + args[1])
                    # Start initially at top left, but subsequent args
                    # may change this:
                    mapwin.center_lon, mapwin.center_lat = \
                        mapwin.collection.get_top_left()
                    if (Debug):
                        print "Collection", mapwin.collection.name,
                        print "Starting at", \
                            MapUtils.DecDegToDegMinStr(mapwin.center_lon), \
                            ", ", MapUtils.DecDegToDegMinStr(mapwin.center_lat)
                    args = args[1:]

                elif args[0] == "-d":
                    Debug = True
                elif args[0] == "-t" and len(args) > 1:
                    if mapwin.trackpoints == None:
                        mapwin.trackpoints = TrackPoints()

                    # Is it a known track?
                    for tr in self.KnownTracks:
                        if args[1] == tr[0]:
                            if Debug:
                                print "Reading known track", tr[0], tr[1]
                            args[1] = tr[1]
                            break

                    try:
                        mapwin.trackpoints.readTrackFile(args[1])
                    except IOError:
                        print "Can't read track file", args[1]
                    args = args[1:]
                else:
                    PyTopo.error_out("Unknown flag " + args[0])

                # Done processing this flag
                args = args[1:]
                continue

            # args[0] doesn't start with '-'. Is it a gpx or kml file?
            if args[0].endswith(".gpx") \
               or args[0].endswith(".kml") \
               or args[0].endswith(".kmz"):
                try:
                    if mapwin.trackpoints:
                        mapwin.trackpoints.readTrackFile(args[0])
                    else:
                        trackpoints = TrackPoints()
                        trackpoints.readTrackFile(args[0])
                        mapwin.trackpoints = trackpoints
                except IOError:
                    print "Can't read track file", args[0]
                except xml.parsers.expat.ExpatError:
                    print "Can't read %s: syntax error." % args[0]
                    if args[0].lower().endswith(".kml") or \
                       args[0].lower().endswith(".kmz"):
                        print """
Is this a KML made with ArcGIS?
It may have an illegal xsi:schemaLocation.
If so, try changing xsi:schemaLocation to just schemaLocation."""
                args = args[1:]
                continue

            # Try to match a known site:
            for site in self.KnownSites:
                if args[0] == site[0]:
                    if not self.use_site(site, mapwin):
                        continue
                    break

            if mapwin.collection and mapwin.center_lon and mapwin.center_lat:
                args = args[1:]
                continue

            # Doesn't match a known site. Maybe the args are coordinates?
            try:
                if len(args) >= 2 and \
                   len(args[0] > 1 and args[0][1].isdigit) and \
                   len(args[1] > 1 and args[1][1].isdigit):
                    mapwin.center_lon = MapUtils.DegMinToDecDeg(float(args[0]))
                    mapwin.center_lat = MapUtils.DegMinToDecDeg(float(args[2]))
                    mapwin.collection = self.find_collection(args[3])
                    args = args[2:]
                    continue

            except ValueError, e:
                print "Couldn't parse coordinates"
                PyTopo.Usage()

            # If we get here, we still have an argument but it doesn't
            # match anything we know: flag, collection, site or coordinate.
            print "Remaining args:", args
            PyTopo.Usage()

        # Now we've parsed all the arguments.
        # If we didn't get a collection, use the default, if any:
        if not mapwin.collection and self.default_collection:
            mapwin.collection = self.find_collection(self.default_collection)

        # If we have a collection and a track but no center point,
        # center it on the trackpoints, and set scale appropriately:
        if mapwin.trackpoints != None and mapwin.collection != None \
                and not (mapwin.center_lat and mapwin.center_lon):
            minlon, minlat, maxlon, maxlat = mapwin.trackpoints.get_bounds()
            mapwin.center_lon = (maxlon + minlon) / 2
            mapwin.center_lat = (maxlat + minlat) / 2
            mapwin.collection.zoom_to_bounds(minlon, minlat, maxlon, maxlat)

        # By now, we hope we have the mapwin positioned with a collection
        # and starting coordinates:
        if mapwin.collection and mapwin.center_lon and mapwin.center_lat:
            return

        # Didn't match any known run mode:
        # start in GUI mode choosing a location:
        if not self.selection_window(mapwin):
            sys.exit(0)

# Check for a user config file named .pytopo
# in either $HOME/.config/pytopo or $HOME.
#
# Format of the user config file:
# It is a python script, which can include arbitrary python code,
# but the most useful will be KnownSites definitions,
# with coordinates specified in degrees.decimal_minutes,
# like this:
# MapHome = "/cdrom"
# KnownSites = [
#     # Death Valley
#     [ "zabriskie", 116.475, 36.245, "dv_data" ],
#     [ "badwater", 116.445, 36.125, "dv_data" ],
#     # East Mojave
#     [ "zzyzyx", 116.05, 35.08, "emj_data" ]
#     ]

    def exec_config_file(self):
        """Load the user's .pytopo config file,
        found either in $HOME/.config/pytopo/ or $HOME/pytopo.
        """
        userfile = os.path.join(self.config_dir, "pytopo.sites")
        if not os.access(userfile, os.R_OK):
            if Debug:
                print "Couldn't open", userfile
            userfile = os.path.expanduser("~/.pytopo")
            if not os.access(userfile, os.R_OK):
                if Debug:
                    print "Couldn't open", userfile, "either"
                userfile = os.path.join(self.config_dir, "pytopo", ".pytopo")
                if not os.access(userfile, os.R_OK):
                    if Debug:
                        print "Couldn't open", userfile, "either"
                    userfile = self.create_initial_config()
                    if userfile == None:
                        print "Couldn't create a new pytopo config file"
                        return
                else:
                    print "Suggestion: rename", userfile, \
                          "to ~/.config/pytopo/pytopo.sites"
                    print userfile, "may eventually be deprecated"
        if Debug:
            print "Found", userfile

        # Now we'd better have a userfile

        # Now that we're in a function inside the PyTopo class, we can't
        # just execfile() and set a variable inside that file -- the file
        # can only change it inside a "locals" dictionary.
        # So set up the dictionary:
        locals =  { 'Collections' : [ 3, 4 ],
                    'KnownSites' : [],
                    'init_width' : self.init_width,
                    'init_height' : self.init_height
                  }
        execfile(userfile, globals(), locals)

        # Then extract the changed values back out:
        self.collections = locals['Collections']
        self.KnownSites = locals['KnownSites']
        self.init_width = locals["init_width"]
        self.init_height = locals["init_height"]
        self.default_collection = locals["defaultCollection"]

    def read_saved_sites(self):
        """Read previously saved (favorite) sites."""
        global Debug
        try:
            savefile = open(self.savefilename, "r")
        except:
            return

        # A line typically looks like this:
        # [ "san-francisco", -121.750000, 37.400000, "openstreetmap" ]
        # or, with an extra optional zoom level,
        # [ "san-francisco", -121.750000, 37.400000, "openstreetmap", 11 ]

        r = re.compile('\["([^"]*)",([-0-9\.]*),([-0-9\.]*),"([^"]*)",?([0-9]+)?\]')
        for line in savefile:
            # First remove all whitespace:
            line = re.sub(r'\s', '', line)
            match = r.search(line)
            if match:
                matches = match.groups()
                # Convert from strings to numbers
                site = [ matches[0], float(matches[1]), float(matches[2]),
                         matches[3] ]
                if len(matches) == 5 and matches[4] != None:
                    site.append(int(matches[4]))
                if Debug:
                    print "Adding", site[0], "to KnownSites"
                self.KnownSites.append( site )

        savefile.close()

    def read_tracks(self):
        trackdir = os.path.expanduser('~/Tracks')

        if os.path.isdir(trackdir):
            for file in glob.glob( os.path.join(trackdir, '*.gpx') ):
                head, gpx = os.path.split(file)
                filename = gpx.partition('.')[0]
                self.KnownTracks.append( [filename, file] )

    def create_initial_config(self):
        """Make an initial configuration file.
           If the user has a ~/.config, make ~/.config/pytopo/pytopo.sites
           else fall back on ~/.pytopo.
        """
        confdir = os.path.expanduser("~/.config/pytopo")
        try:
            if not os.access(confdir, os.W_OK):
                os.mkdir(confdir)
            userfile = os.path.join(confdir, "pytopo.sites")
            fp = open(userfile, 'w')
        except:
            fp = None
        if not fp:
            userfile = os.path.expanduser("~/.pytopo")
            try:
                fp = open(userfile, 'w')
            except:
                return None

        # Now we have fp open. Write a very basic config to it.
        print >>fp, """# Pytopo site file

# Map collections

Collections = [
    OSMMapCollection( "openstreetmap", "~/Maps/openstreetmap",
                      ".png", 256, 256, 10,
                      "http://a.tile.openstreetmap.org" ),
    OSMMapCollection( "opencyclemap", "~/Maps/opencyclemap",
                      ".png", 256, 256, 13,
                      "http://b.tile.opencyclemap.org/cycle",
                      maxzoom=18),
    OSMMapCollection( "satellite", "~/Maps/openaerial",
                      ".jpg", 256, 256, 13,
                      "http://otile1.mqcdn.com/tiles/1.0.0/sat",
                      maxzoom=18),
    OSMMapCollection( "mapquest", "~/Maps/mapquest",
                      ".jpg", 256, 256, 13,
                      "http://otile1.mqcdn.com/tiles/1.0.0/map"),
    ]

defaultCollection = "openstreetmap"

KnownSites = [
    # Some base values to get new users started.
    # Note that these coordinates are a bit northwest of the city centers;
    # they're the coordinates of the map top left, not center.
    [ "san-francisco", -121.75, 37.4, "openstreetmap" ],
    [ "new-york", -73.466, 40.392, "openstreetmap" ],
    [ "london", 0.1, 51.266, "openstreetmap" ],
    [ "sydney", 151.0, -33.5, "openstreetmap" ],
    ]
"""
        fp.close()

        print """Welcome to Pytopo!
Created an initial site file in %s
You can add new sites and collections there; see the instructions at
   http://shallowsky.com/software/topo/
""" % (userfile)
        return userfile

    def main(self, pytopo_args):
        """main execution routine for pytopo."""
        self.exec_config_file()
        # Remember how many known sites we got from the config file;
        # the rest are read in from saved sites and may need to be re-saved.
        self.first_saved_site = len(self.KnownSites)
        self.read_saved_sites()
        self.read_tracks()
        gc.enable()

        mapwin = MapWindow(self)

        self.parse_args(mapwin, pytopo_args)

        # For cProfile testing, run with a dummy collection (no data needed):
        #mapwin.collection = MapCollection("dummy", "/tmp")

        #print cProfile.__file__
        #cProfile.run('mapwin.show_window()', 'cprof.out')
        # http://docs.python.org/library/profile.html
        # To analyze cprof.out output, do this:
        # import pstats
        # p = pstats.Stats('fooprof')
        # p.sort_stats('time').print_stats(20)

        mapwin.show_window(self.init_width, self.init_height)

#####################################################################
# Some global routines that really should get moved into a class:
#

# A relatively clean way of downloading files in a separate thread.
# http://code.activestate.com/recipes/577129-run-asynchronous-tasks-using-coroutines/
#
def start_job(generator):
    """Start a job (a coroutine that yield generic tasks)."""
    def _task_return(result):
        """Function to be sent to tasks to be used as task_return."""
        def _advance_generator():
            try:
                new_task = generator.send(result)
            except StopIteration:
                return
            new_task(_task_return)
        # make sure the generator is advanced in the main thread
        gobject.idle_add(_advance_generator)
    _task_return(None)
    return generator

import threading
gobject.threads_init()

def threaded_task(function, *args, **kwargs):
    """Run function(*args, **kwargs) inside a thread and return the result."""
    def _task(task_return):
        def _thread():
            result = function(*args, **kwargs)
            gobject.idle_add(task_return, result)
        thread = threading.Thread(target=_thread, args=())
        thread.setDaemon(True)
        thread.start()
    return _task

def download_job(url, localpath, callback):
    def download(url, localpath, callback):
        global magic_parser
        if Debug:
            print "Downloading", url
        try:
            urllib.urlretrieve(url, localpath)
        except IOError, e:
            print "Couldn't download", url, ":"
            print e
            return None

        if magic_parser == None:
            try:
                import magic
                magic_parser = magic.open(magic.MAGIC_MIME)
                magic_parser.load()
            except:
                magic_parser = False
        if magic_parser:
            mimetype = magic_parser.file(localpath)
            if not mimetype.startswith("image/"):
                print "Problem downloading", localpath
                print "Type:", mimetype
                # Opencyclemap, at least, sometimes serves text files
                # that say "tile not available". Other servers may serve
                # HTML files. If it's text, give the user a chance to see it.
                if mimetype.startswith("text/"):
                    with open(localpath, 'r') as errfile:
                        errstr = errfile.read()
                    # Don't show more than three full lines of error message:
                    if len(errstr) > 240:
                        errstr = errstr[0:100]
                    print 'File contents: "%s"' % errstr.strip()
                else:
                    print "File type is", mimetype

                # Return no local path, so it can be deleted if appropriate.
                return None

        return localpath

    path = yield threaded_task(download, url, localpath, callback)
    if Debug:
        print >>sys.stderr, "[downloaded %s]" % (localpath)
    callback(path)


# Conditional main:
if __name__ == "__main__":
    p = PyTopo()
    p.main(sys.argv)

